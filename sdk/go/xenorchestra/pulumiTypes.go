// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package xenorchestra

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/vatesfr/pulumi-xenorchestra/sdk/go/xenorchestra/internal"
)

var _ = internal.GetEnvOrDefault

type ResourceSetLimit struct {
	// The numerical limit for the given type.
	Quantity int `pulumi:"quantity"`
	// The type of resource set limit. Must be cpus, memory or disk.
	Type string `pulumi:"type"`
}

// ResourceSetLimitInput is an input type that accepts ResourceSetLimitArgs and ResourceSetLimitOutput values.
// You can construct a concrete instance of `ResourceSetLimitInput` via:
//
//	ResourceSetLimitArgs{...}
type ResourceSetLimitInput interface {
	pulumi.Input

	ToResourceSetLimitOutput() ResourceSetLimitOutput
	ToResourceSetLimitOutputWithContext(context.Context) ResourceSetLimitOutput
}

type ResourceSetLimitArgs struct {
	// The numerical limit for the given type.
	Quantity pulumi.IntInput `pulumi:"quantity"`
	// The type of resource set limit. Must be cpus, memory or disk.
	Type pulumi.StringInput `pulumi:"type"`
}

func (ResourceSetLimitArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSetLimit)(nil)).Elem()
}

func (i ResourceSetLimitArgs) ToResourceSetLimitOutput() ResourceSetLimitOutput {
	return i.ToResourceSetLimitOutputWithContext(context.Background())
}

func (i ResourceSetLimitArgs) ToResourceSetLimitOutputWithContext(ctx context.Context) ResourceSetLimitOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceSetLimitOutput)
}

// ResourceSetLimitArrayInput is an input type that accepts ResourceSetLimitArray and ResourceSetLimitArrayOutput values.
// You can construct a concrete instance of `ResourceSetLimitArrayInput` via:
//
//	ResourceSetLimitArray{ ResourceSetLimitArgs{...} }
type ResourceSetLimitArrayInput interface {
	pulumi.Input

	ToResourceSetLimitArrayOutput() ResourceSetLimitArrayOutput
	ToResourceSetLimitArrayOutputWithContext(context.Context) ResourceSetLimitArrayOutput
}

type ResourceSetLimitArray []ResourceSetLimitInput

func (ResourceSetLimitArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceSetLimit)(nil)).Elem()
}

func (i ResourceSetLimitArray) ToResourceSetLimitArrayOutput() ResourceSetLimitArrayOutput {
	return i.ToResourceSetLimitArrayOutputWithContext(context.Background())
}

func (i ResourceSetLimitArray) ToResourceSetLimitArrayOutputWithContext(ctx context.Context) ResourceSetLimitArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceSetLimitArrayOutput)
}

type ResourceSetLimitOutput struct{ *pulumi.OutputState }

func (ResourceSetLimitOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSetLimit)(nil)).Elem()
}

func (o ResourceSetLimitOutput) ToResourceSetLimitOutput() ResourceSetLimitOutput {
	return o
}

func (o ResourceSetLimitOutput) ToResourceSetLimitOutputWithContext(ctx context.Context) ResourceSetLimitOutput {
	return o
}

// The numerical limit for the given type.
func (o ResourceSetLimitOutput) Quantity() pulumi.IntOutput {
	return o.ApplyT(func(v ResourceSetLimit) int { return v.Quantity }).(pulumi.IntOutput)
}

// The type of resource set limit. Must be cpus, memory or disk.
func (o ResourceSetLimitOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ResourceSetLimit) string { return v.Type }).(pulumi.StringOutput)
}

type ResourceSetLimitArrayOutput struct{ *pulumi.OutputState }

func (ResourceSetLimitArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceSetLimit)(nil)).Elem()
}

func (o ResourceSetLimitArrayOutput) ToResourceSetLimitArrayOutput() ResourceSetLimitArrayOutput {
	return o
}

func (o ResourceSetLimitArrayOutput) ToResourceSetLimitArrayOutputWithContext(ctx context.Context) ResourceSetLimitArrayOutput {
	return o
}

func (o ResourceSetLimitArrayOutput) Index(i pulumi.IntInput) ResourceSetLimitOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ResourceSetLimit {
		return vs[0].([]ResourceSetLimit)[vs[1].(int)]
	}).(ResourceSetLimitOutput)
}

type VmCdrom struct {
	// The ID of the ISO (VDI) to attach to the VM. This can be easily provided by using the `vdi` data source.
	Id string `pulumi:"id"`
}

// VmCdromInput is an input type that accepts VmCdromArgs and VmCdromOutput values.
// You can construct a concrete instance of `VmCdromInput` via:
//
//	VmCdromArgs{...}
type VmCdromInput interface {
	pulumi.Input

	ToVmCdromOutput() VmCdromOutput
	ToVmCdromOutputWithContext(context.Context) VmCdromOutput
}

type VmCdromArgs struct {
	// The ID of the ISO (VDI) to attach to the VM. This can be easily provided by using the `vdi` data source.
	Id pulumi.StringInput `pulumi:"id"`
}

func (VmCdromArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VmCdrom)(nil)).Elem()
}

func (i VmCdromArgs) ToVmCdromOutput() VmCdromOutput {
	return i.ToVmCdromOutputWithContext(context.Background())
}

func (i VmCdromArgs) ToVmCdromOutputWithContext(ctx context.Context) VmCdromOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmCdromOutput)
}

func (i VmCdromArgs) ToVmCdromPtrOutput() VmCdromPtrOutput {
	return i.ToVmCdromPtrOutputWithContext(context.Background())
}

func (i VmCdromArgs) ToVmCdromPtrOutputWithContext(ctx context.Context) VmCdromPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmCdromOutput).ToVmCdromPtrOutputWithContext(ctx)
}

// VmCdromPtrInput is an input type that accepts VmCdromArgs, VmCdromPtr and VmCdromPtrOutput values.
// You can construct a concrete instance of `VmCdromPtrInput` via:
//
//	        VmCdromArgs{...}
//
//	or:
//
//	        nil
type VmCdromPtrInput interface {
	pulumi.Input

	ToVmCdromPtrOutput() VmCdromPtrOutput
	ToVmCdromPtrOutputWithContext(context.Context) VmCdromPtrOutput
}

type vmCdromPtrType VmCdromArgs

func VmCdromPtr(v *VmCdromArgs) VmCdromPtrInput {
	return (*vmCdromPtrType)(v)
}

func (*vmCdromPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VmCdrom)(nil)).Elem()
}

func (i *vmCdromPtrType) ToVmCdromPtrOutput() VmCdromPtrOutput {
	return i.ToVmCdromPtrOutputWithContext(context.Background())
}

func (i *vmCdromPtrType) ToVmCdromPtrOutputWithContext(ctx context.Context) VmCdromPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmCdromPtrOutput)
}

type VmCdromOutput struct{ *pulumi.OutputState }

func (VmCdromOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VmCdrom)(nil)).Elem()
}

func (o VmCdromOutput) ToVmCdromOutput() VmCdromOutput {
	return o
}

func (o VmCdromOutput) ToVmCdromOutputWithContext(ctx context.Context) VmCdromOutput {
	return o
}

func (o VmCdromOutput) ToVmCdromPtrOutput() VmCdromPtrOutput {
	return o.ToVmCdromPtrOutputWithContext(context.Background())
}

func (o VmCdromOutput) ToVmCdromPtrOutputWithContext(ctx context.Context) VmCdromPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v VmCdrom) *VmCdrom {
		return &v
	}).(VmCdromPtrOutput)
}

// The ID of the ISO (VDI) to attach to the VM. This can be easily provided by using the `vdi` data source.
func (o VmCdromOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v VmCdrom) string { return v.Id }).(pulumi.StringOutput)
}

type VmCdromPtrOutput struct{ *pulumi.OutputState }

func (VmCdromPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VmCdrom)(nil)).Elem()
}

func (o VmCdromPtrOutput) ToVmCdromPtrOutput() VmCdromPtrOutput {
	return o
}

func (o VmCdromPtrOutput) ToVmCdromPtrOutputWithContext(ctx context.Context) VmCdromPtrOutput {
	return o
}

func (o VmCdromPtrOutput) Elem() VmCdromOutput {
	return o.ApplyT(func(v *VmCdrom) VmCdrom {
		if v != nil {
			return *v
		}
		var ret VmCdrom
		return ret
	}).(VmCdromOutput)
}

// The ID of the ISO (VDI) to attach to the VM. This can be easily provided by using the `vdi` data source.
func (o VmCdromPtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmCdrom) *string {
		if v == nil {
			return nil
		}
		return &v.Id
	}).(pulumi.StringPtrOutput)
}

type VmDisk struct {
	// Whether the device should be attached to the VM.
	Attached *bool `pulumi:"attached"`
	// The description for the disk
	NameDescription *string `pulumi:"nameDescription"`
	// The name for the disk
	NameLabel string `pulumi:"nameLabel"`
	// Indicates the order of the block device.
	Position *string `pulumi:"position"`
	// The size in bytes for the disk.
	Size int `pulumi:"size"`
	// The storage repository ID to use.
	SrId  string  `pulumi:"srId"`
	VbdId *string `pulumi:"vbdId"`
	VdiId *string `pulumi:"vdiId"`
}

// VmDiskInput is an input type that accepts VmDiskArgs and VmDiskOutput values.
// You can construct a concrete instance of `VmDiskInput` via:
//
//	VmDiskArgs{...}
type VmDiskInput interface {
	pulumi.Input

	ToVmDiskOutput() VmDiskOutput
	ToVmDiskOutputWithContext(context.Context) VmDiskOutput
}

type VmDiskArgs struct {
	// Whether the device should be attached to the VM.
	Attached pulumi.BoolPtrInput `pulumi:"attached"`
	// The description for the disk
	NameDescription pulumi.StringPtrInput `pulumi:"nameDescription"`
	// The name for the disk
	NameLabel pulumi.StringInput `pulumi:"nameLabel"`
	// Indicates the order of the block device.
	Position pulumi.StringPtrInput `pulumi:"position"`
	// The size in bytes for the disk.
	Size pulumi.IntInput `pulumi:"size"`
	// The storage repository ID to use.
	SrId  pulumi.StringInput    `pulumi:"srId"`
	VbdId pulumi.StringPtrInput `pulumi:"vbdId"`
	VdiId pulumi.StringPtrInput `pulumi:"vdiId"`
}

func (VmDiskArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VmDisk)(nil)).Elem()
}

func (i VmDiskArgs) ToVmDiskOutput() VmDiskOutput {
	return i.ToVmDiskOutputWithContext(context.Background())
}

func (i VmDiskArgs) ToVmDiskOutputWithContext(ctx context.Context) VmDiskOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmDiskOutput)
}

// VmDiskArrayInput is an input type that accepts VmDiskArray and VmDiskArrayOutput values.
// You can construct a concrete instance of `VmDiskArrayInput` via:
//
//	VmDiskArray{ VmDiskArgs{...} }
type VmDiskArrayInput interface {
	pulumi.Input

	ToVmDiskArrayOutput() VmDiskArrayOutput
	ToVmDiskArrayOutputWithContext(context.Context) VmDiskArrayOutput
}

type VmDiskArray []VmDiskInput

func (VmDiskArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VmDisk)(nil)).Elem()
}

func (i VmDiskArray) ToVmDiskArrayOutput() VmDiskArrayOutput {
	return i.ToVmDiskArrayOutputWithContext(context.Background())
}

func (i VmDiskArray) ToVmDiskArrayOutputWithContext(ctx context.Context) VmDiskArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmDiskArrayOutput)
}

type VmDiskOutput struct{ *pulumi.OutputState }

func (VmDiskOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VmDisk)(nil)).Elem()
}

func (o VmDiskOutput) ToVmDiskOutput() VmDiskOutput {
	return o
}

func (o VmDiskOutput) ToVmDiskOutputWithContext(ctx context.Context) VmDiskOutput {
	return o
}

// Whether the device should be attached to the VM.
func (o VmDiskOutput) Attached() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VmDisk) *bool { return v.Attached }).(pulumi.BoolPtrOutput)
}

// The description for the disk
func (o VmDiskOutput) NameDescription() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmDisk) *string { return v.NameDescription }).(pulumi.StringPtrOutput)
}

// The name for the disk
func (o VmDiskOutput) NameLabel() pulumi.StringOutput {
	return o.ApplyT(func(v VmDisk) string { return v.NameLabel }).(pulumi.StringOutput)
}

// Indicates the order of the block device.
func (o VmDiskOutput) Position() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmDisk) *string { return v.Position }).(pulumi.StringPtrOutput)
}

// The size in bytes for the disk.
func (o VmDiskOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v VmDisk) int { return v.Size }).(pulumi.IntOutput)
}

// The storage repository ID to use.
func (o VmDiskOutput) SrId() pulumi.StringOutput {
	return o.ApplyT(func(v VmDisk) string { return v.SrId }).(pulumi.StringOutput)
}

func (o VmDiskOutput) VbdId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmDisk) *string { return v.VbdId }).(pulumi.StringPtrOutput)
}

func (o VmDiskOutput) VdiId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmDisk) *string { return v.VdiId }).(pulumi.StringPtrOutput)
}

type VmDiskArrayOutput struct{ *pulumi.OutputState }

func (VmDiskArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VmDisk)(nil)).Elem()
}

func (o VmDiskArrayOutput) ToVmDiskArrayOutput() VmDiskArrayOutput {
	return o
}

func (o VmDiskArrayOutput) ToVmDiskArrayOutputWithContext(ctx context.Context) VmDiskArrayOutput {
	return o
}

func (o VmDiskArrayOutput) Index(i pulumi.IntInput) VmDiskOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VmDisk {
		return vs[0].([]VmDisk)[vs[1].(int)]
	}).(VmDiskOutput)
}

type VmNetwork struct {
	// Whether the device should be attached to the VM.
	Attached       *bool    `pulumi:"attached"`
	Device         *string  `pulumi:"device"`
	ExpectedIpCidr *string  `pulumi:"expectedIpCidr"`
	Ipv4Addresses  []string `pulumi:"ipv4Addresses"`
	Ipv6Addresses  []string `pulumi:"ipv6Addresses"`
	MacAddress     *string  `pulumi:"macAddress"`
	// The ID of the network the VM will be on.
	NetworkId string `pulumi:"networkId"`
}

// VmNetworkInput is an input type that accepts VmNetworkArgs and VmNetworkOutput values.
// You can construct a concrete instance of `VmNetworkInput` via:
//
//	VmNetworkArgs{...}
type VmNetworkInput interface {
	pulumi.Input

	ToVmNetworkOutput() VmNetworkOutput
	ToVmNetworkOutputWithContext(context.Context) VmNetworkOutput
}

type VmNetworkArgs struct {
	// Whether the device should be attached to the VM.
	Attached       pulumi.BoolPtrInput     `pulumi:"attached"`
	Device         pulumi.StringPtrInput   `pulumi:"device"`
	ExpectedIpCidr pulumi.StringPtrInput   `pulumi:"expectedIpCidr"`
	Ipv4Addresses  pulumi.StringArrayInput `pulumi:"ipv4Addresses"`
	Ipv6Addresses  pulumi.StringArrayInput `pulumi:"ipv6Addresses"`
	MacAddress     pulumi.StringPtrInput   `pulumi:"macAddress"`
	// The ID of the network the VM will be on.
	NetworkId pulumi.StringInput `pulumi:"networkId"`
}

func (VmNetworkArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VmNetwork)(nil)).Elem()
}

func (i VmNetworkArgs) ToVmNetworkOutput() VmNetworkOutput {
	return i.ToVmNetworkOutputWithContext(context.Background())
}

func (i VmNetworkArgs) ToVmNetworkOutputWithContext(ctx context.Context) VmNetworkOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmNetworkOutput)
}

// VmNetworkArrayInput is an input type that accepts VmNetworkArray and VmNetworkArrayOutput values.
// You can construct a concrete instance of `VmNetworkArrayInput` via:
//
//	VmNetworkArray{ VmNetworkArgs{...} }
type VmNetworkArrayInput interface {
	pulumi.Input

	ToVmNetworkArrayOutput() VmNetworkArrayOutput
	ToVmNetworkArrayOutputWithContext(context.Context) VmNetworkArrayOutput
}

type VmNetworkArray []VmNetworkInput

func (VmNetworkArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VmNetwork)(nil)).Elem()
}

func (i VmNetworkArray) ToVmNetworkArrayOutput() VmNetworkArrayOutput {
	return i.ToVmNetworkArrayOutputWithContext(context.Background())
}

func (i VmNetworkArray) ToVmNetworkArrayOutputWithContext(ctx context.Context) VmNetworkArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmNetworkArrayOutput)
}

type VmNetworkOutput struct{ *pulumi.OutputState }

func (VmNetworkOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VmNetwork)(nil)).Elem()
}

func (o VmNetworkOutput) ToVmNetworkOutput() VmNetworkOutput {
	return o
}

func (o VmNetworkOutput) ToVmNetworkOutputWithContext(ctx context.Context) VmNetworkOutput {
	return o
}

// Whether the device should be attached to the VM.
func (o VmNetworkOutput) Attached() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VmNetwork) *bool { return v.Attached }).(pulumi.BoolPtrOutput)
}

func (o VmNetworkOutput) Device() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmNetwork) *string { return v.Device }).(pulumi.StringPtrOutput)
}

func (o VmNetworkOutput) ExpectedIpCidr() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmNetwork) *string { return v.ExpectedIpCidr }).(pulumi.StringPtrOutput)
}

func (o VmNetworkOutput) Ipv4Addresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VmNetwork) []string { return v.Ipv4Addresses }).(pulumi.StringArrayOutput)
}

func (o VmNetworkOutput) Ipv6Addresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VmNetwork) []string { return v.Ipv6Addresses }).(pulumi.StringArrayOutput)
}

func (o VmNetworkOutput) MacAddress() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmNetwork) *string { return v.MacAddress }).(pulumi.StringPtrOutput)
}

// The ID of the network the VM will be on.
func (o VmNetworkOutput) NetworkId() pulumi.StringOutput {
	return o.ApplyT(func(v VmNetwork) string { return v.NetworkId }).(pulumi.StringOutput)
}

type VmNetworkArrayOutput struct{ *pulumi.OutputState }

func (VmNetworkArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VmNetwork)(nil)).Elem()
}

func (o VmNetworkArrayOutput) ToVmNetworkArrayOutput() VmNetworkArrayOutput {
	return o
}

func (o VmNetworkArrayOutput) ToVmNetworkArrayOutputWithContext(ctx context.Context) VmNetworkArrayOutput {
	return o
}

func (o VmNetworkArrayOutput) Index(i pulumi.IntInput) VmNetworkOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VmNetwork {
		return vs[0].([]VmNetwork)[vs[1].(int)]
	}).(VmNetworkOutput)
}

type GetHostsHost struct {
	// CPU information about the host. The 'cores' key will contain the number of cpu cores and the 'sockets' key will contain the number of sockets.
	Cpus map[string]int `pulumi:"cpus"`
	Id   string         `pulumi:"id"`
	// The memory size of the host.
	Memory int `pulumi:"memory"`
	// The memory usage of the host.
	MemoryUsage int `pulumi:"memoryUsage"`
	// The name label of the host.
	NameLabel string `pulumi:"nameLabel"`
	// Id of the pool that the host belongs to.
	PoolId string `pulumi:"poolId"`
	// The tags (labels) applied to the given entity.
	Tags []string `pulumi:"tags"`
}

// GetHostsHostInput is an input type that accepts GetHostsHostArgs and GetHostsHostOutput values.
// You can construct a concrete instance of `GetHostsHostInput` via:
//
//	GetHostsHostArgs{...}
type GetHostsHostInput interface {
	pulumi.Input

	ToGetHostsHostOutput() GetHostsHostOutput
	ToGetHostsHostOutputWithContext(context.Context) GetHostsHostOutput
}

type GetHostsHostArgs struct {
	// CPU information about the host. The 'cores' key will contain the number of cpu cores and the 'sockets' key will contain the number of sockets.
	Cpus pulumi.IntMapInput `pulumi:"cpus"`
	Id   pulumi.StringInput `pulumi:"id"`
	// The memory size of the host.
	Memory pulumi.IntInput `pulumi:"memory"`
	// The memory usage of the host.
	MemoryUsage pulumi.IntInput `pulumi:"memoryUsage"`
	// The name label of the host.
	NameLabel pulumi.StringInput `pulumi:"nameLabel"`
	// Id of the pool that the host belongs to.
	PoolId pulumi.StringInput `pulumi:"poolId"`
	// The tags (labels) applied to the given entity.
	Tags pulumi.StringArrayInput `pulumi:"tags"`
}

func (GetHostsHostArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetHostsHost)(nil)).Elem()
}

func (i GetHostsHostArgs) ToGetHostsHostOutput() GetHostsHostOutput {
	return i.ToGetHostsHostOutputWithContext(context.Background())
}

func (i GetHostsHostArgs) ToGetHostsHostOutputWithContext(ctx context.Context) GetHostsHostOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetHostsHostOutput)
}

// GetHostsHostArrayInput is an input type that accepts GetHostsHostArray and GetHostsHostArrayOutput values.
// You can construct a concrete instance of `GetHostsHostArrayInput` via:
//
//	GetHostsHostArray{ GetHostsHostArgs{...} }
type GetHostsHostArrayInput interface {
	pulumi.Input

	ToGetHostsHostArrayOutput() GetHostsHostArrayOutput
	ToGetHostsHostArrayOutputWithContext(context.Context) GetHostsHostArrayOutput
}

type GetHostsHostArray []GetHostsHostInput

func (GetHostsHostArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetHostsHost)(nil)).Elem()
}

func (i GetHostsHostArray) ToGetHostsHostArrayOutput() GetHostsHostArrayOutput {
	return i.ToGetHostsHostArrayOutputWithContext(context.Background())
}

func (i GetHostsHostArray) ToGetHostsHostArrayOutputWithContext(ctx context.Context) GetHostsHostArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetHostsHostArrayOutput)
}

type GetHostsHostOutput struct{ *pulumi.OutputState }

func (GetHostsHostOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetHostsHost)(nil)).Elem()
}

func (o GetHostsHostOutput) ToGetHostsHostOutput() GetHostsHostOutput {
	return o
}

func (o GetHostsHostOutput) ToGetHostsHostOutputWithContext(ctx context.Context) GetHostsHostOutput {
	return o
}

// CPU information about the host. The 'cores' key will contain the number of cpu cores and the 'sockets' key will contain the number of sockets.
func (o GetHostsHostOutput) Cpus() pulumi.IntMapOutput {
	return o.ApplyT(func(v GetHostsHost) map[string]int { return v.Cpus }).(pulumi.IntMapOutput)
}

func (o GetHostsHostOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetHostsHost) string { return v.Id }).(pulumi.StringOutput)
}

// The memory size of the host.
func (o GetHostsHostOutput) Memory() pulumi.IntOutput {
	return o.ApplyT(func(v GetHostsHost) int { return v.Memory }).(pulumi.IntOutput)
}

// The memory usage of the host.
func (o GetHostsHostOutput) MemoryUsage() pulumi.IntOutput {
	return o.ApplyT(func(v GetHostsHost) int { return v.MemoryUsage }).(pulumi.IntOutput)
}

// The name label of the host.
func (o GetHostsHostOutput) NameLabel() pulumi.StringOutput {
	return o.ApplyT(func(v GetHostsHost) string { return v.NameLabel }).(pulumi.StringOutput)
}

// Id of the pool that the host belongs to.
func (o GetHostsHostOutput) PoolId() pulumi.StringOutput {
	return o.ApplyT(func(v GetHostsHost) string { return v.PoolId }).(pulumi.StringOutput)
}

// The tags (labels) applied to the given entity.
func (o GetHostsHostOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetHostsHost) []string { return v.Tags }).(pulumi.StringArrayOutput)
}

type GetHostsHostArrayOutput struct{ *pulumi.OutputState }

func (GetHostsHostArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetHostsHost)(nil)).Elem()
}

func (o GetHostsHostArrayOutput) ToGetHostsHostArrayOutput() GetHostsHostArrayOutput {
	return o
}

func (o GetHostsHostArrayOutput) ToGetHostsHostArrayOutputWithContext(ctx context.Context) GetHostsHostArrayOutput {
	return o
}

func (o GetHostsHostArrayOutput) Index(i pulumi.IntInput) GetHostsHostOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetHostsHost {
		return vs[0].([]GetHostsHost)[vs[1].(int)]
	}).(GetHostsHostOutput)
}

type GetVmsVm struct {
	// The preferred host you would like the VM to run on. If changed on an existing VM it will require a reboot for the VM to be rescheduled.
	AffinityHost *string `pulumi:"affinityHost"`
	// If the VM will automatically turn on. Defaults to `false`.
	AutoPoweron *bool `pulumi:"autoPoweron"`
	// List of operations on a VM that are not permitted. Examples include: clean_reboot, clean_shutdown, hard_reboot, hard_shutdown, pause, shutdown, suspend, destroy. This can be used to prevent a VM from being destroyed. The entire list can be found here
	BlockedOperations []string `pulumi:"blockedOperations"`
	// The type of clone to perform for the VM. Possible values include `fast` or `full` and defaults to `fast`. In order to perform a `full` clone, the VM template must not be a disk template.
	CloneType *string `pulumi:"cloneType"`
	// The content of the cloud-init config to use. See the cloud init docs for more [information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).
	CloudConfig *string `pulumi:"cloudConfig"`
	// The content of the cloud-init network configuration for the VM (uses [version 1](https://cloudinit.readthedocs.io/en/latest/topics/network-config-format-v1.html))
	CloudNetworkConfig *string `pulumi:"cloudNetworkConfig"`
	CoreOs             *bool   `pulumi:"coreOs"`
	CpuCap             *int    `pulumi:"cpuCap"`
	CpuWeight          *int    `pulumi:"cpuWeight"`
	// The number of CPUs the VM will have. Updates to this field will cause a stop and start of the VM if the new CPU value is greater than the max CPU value. This can be determined with the following command:
	Cpus int `pulumi:"cpus"`
	// The disk the VM will have access to.
	Disks []GetVmsVmDisk `pulumi:"disks"`
	// Boolean parameter that allows a VM to use nested virtualization.
	ExpNestedHvm *bool `pulumi:"expNestedHvm"`
	// The restart priority for the VM. Possible values are `best-effort`, `restart` and empty string (no restarts on failure. Defaults to empty string
	HighAvailability *string `pulumi:"highAvailability"`
	Host             *string `pulumi:"host"`
	// The firmware to use for the VM. Possible values are `bios` and `uefi`.
	HvmBootFirmware *string  `pulumi:"hvmBootFirmware"`
	Id              string   `pulumi:"id"`
	Ipv4Addresses   []string `pulumi:"ipv4Addresses"`
	// This is only accessible if guest-tools is installed in the VM and if `expectedIpCidr` is set on any network interfaces. This will contain a list of the ipv6 addresses across all network interfaces in order.
	Ipv6Addresses []string `pulumi:"ipv6Addresses"`
	// The amount of memory in bytes the VM will have. Updates to this field will case a stop and start of the VM if the new value is greater than the dynamic memory max. This can be determined with the following command:
	MemoryMax int `pulumi:"memoryMax"`
	// The description of the VM.
	NameDescription *string `pulumi:"nameDescription"`
	// The name of the VM.
	NameLabel string `pulumi:"nameLabel"`
	// The network for the VM.
	Networks []GetVmsVmNetwork `pulumi:"networks"`
	// The power state of the VM. This can be Running, Halted, Paused or Suspended.
	PowerState  *string `pulumi:"powerState"`
	ResourceSet *string `pulumi:"resourceSet"`
	// Number of seconds the VM should be delayed from starting.
	StartDelay *int `pulumi:"startDelay"`
	// The tags (labels) applied to the given entity.
	Tags []string `pulumi:"tags"`
	// The ID of the VM template to create the new VM from.
	Template string `pulumi:"template"`
	// The video adapter the VM should use. Possible values include std and cirrus.
	Vga *string `pulumi:"vga"`
	// The videoram option the VM should use. Possible values include 1, 2, 4, 8, 16
	Videoram *int `pulumi:"videoram"`
	// The key value pairs to be populated in xenstore.
	Xenstore map[string]string `pulumi:"xenstore"`
}

// GetVmsVmInput is an input type that accepts GetVmsVmArgs and GetVmsVmOutput values.
// You can construct a concrete instance of `GetVmsVmInput` via:
//
//	GetVmsVmArgs{...}
type GetVmsVmInput interface {
	pulumi.Input

	ToGetVmsVmOutput() GetVmsVmOutput
	ToGetVmsVmOutputWithContext(context.Context) GetVmsVmOutput
}

type GetVmsVmArgs struct {
	// The preferred host you would like the VM to run on. If changed on an existing VM it will require a reboot for the VM to be rescheduled.
	AffinityHost pulumi.StringPtrInput `pulumi:"affinityHost"`
	// If the VM will automatically turn on. Defaults to `false`.
	AutoPoweron pulumi.BoolPtrInput `pulumi:"autoPoweron"`
	// List of operations on a VM that are not permitted. Examples include: clean_reboot, clean_shutdown, hard_reboot, hard_shutdown, pause, shutdown, suspend, destroy. This can be used to prevent a VM from being destroyed. The entire list can be found here
	BlockedOperations pulumi.StringArrayInput `pulumi:"blockedOperations"`
	// The type of clone to perform for the VM. Possible values include `fast` or `full` and defaults to `fast`. In order to perform a `full` clone, the VM template must not be a disk template.
	CloneType pulumi.StringPtrInput `pulumi:"cloneType"`
	// The content of the cloud-init config to use. See the cloud init docs for more [information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).
	CloudConfig pulumi.StringPtrInput `pulumi:"cloudConfig"`
	// The content of the cloud-init network configuration for the VM (uses [version 1](https://cloudinit.readthedocs.io/en/latest/topics/network-config-format-v1.html))
	CloudNetworkConfig pulumi.StringPtrInput `pulumi:"cloudNetworkConfig"`
	CoreOs             pulumi.BoolPtrInput   `pulumi:"coreOs"`
	CpuCap             pulumi.IntPtrInput    `pulumi:"cpuCap"`
	CpuWeight          pulumi.IntPtrInput    `pulumi:"cpuWeight"`
	// The number of CPUs the VM will have. Updates to this field will cause a stop and start of the VM if the new CPU value is greater than the max CPU value. This can be determined with the following command:
	Cpus pulumi.IntInput `pulumi:"cpus"`
	// The disk the VM will have access to.
	Disks GetVmsVmDiskArrayInput `pulumi:"disks"`
	// Boolean parameter that allows a VM to use nested virtualization.
	ExpNestedHvm pulumi.BoolPtrInput `pulumi:"expNestedHvm"`
	// The restart priority for the VM. Possible values are `best-effort`, `restart` and empty string (no restarts on failure. Defaults to empty string
	HighAvailability pulumi.StringPtrInput `pulumi:"highAvailability"`
	Host             pulumi.StringPtrInput `pulumi:"host"`
	// The firmware to use for the VM. Possible values are `bios` and `uefi`.
	HvmBootFirmware pulumi.StringPtrInput   `pulumi:"hvmBootFirmware"`
	Id              pulumi.StringInput      `pulumi:"id"`
	Ipv4Addresses   pulumi.StringArrayInput `pulumi:"ipv4Addresses"`
	// This is only accessible if guest-tools is installed in the VM and if `expectedIpCidr` is set on any network interfaces. This will contain a list of the ipv6 addresses across all network interfaces in order.
	Ipv6Addresses pulumi.StringArrayInput `pulumi:"ipv6Addresses"`
	// The amount of memory in bytes the VM will have. Updates to this field will case a stop and start of the VM if the new value is greater than the dynamic memory max. This can be determined with the following command:
	MemoryMax pulumi.IntInput `pulumi:"memoryMax"`
	// The description of the VM.
	NameDescription pulumi.StringPtrInput `pulumi:"nameDescription"`
	// The name of the VM.
	NameLabel pulumi.StringInput `pulumi:"nameLabel"`
	// The network for the VM.
	Networks GetVmsVmNetworkArrayInput `pulumi:"networks"`
	// The power state of the VM. This can be Running, Halted, Paused or Suspended.
	PowerState  pulumi.StringPtrInput `pulumi:"powerState"`
	ResourceSet pulumi.StringPtrInput `pulumi:"resourceSet"`
	// Number of seconds the VM should be delayed from starting.
	StartDelay pulumi.IntPtrInput `pulumi:"startDelay"`
	// The tags (labels) applied to the given entity.
	Tags pulumi.StringArrayInput `pulumi:"tags"`
	// The ID of the VM template to create the new VM from.
	Template pulumi.StringInput `pulumi:"template"`
	// The video adapter the VM should use. Possible values include std and cirrus.
	Vga pulumi.StringPtrInput `pulumi:"vga"`
	// The videoram option the VM should use. Possible values include 1, 2, 4, 8, 16
	Videoram pulumi.IntPtrInput `pulumi:"videoram"`
	// The key value pairs to be populated in xenstore.
	Xenstore pulumi.StringMapInput `pulumi:"xenstore"`
}

func (GetVmsVmArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetVmsVm)(nil)).Elem()
}

func (i GetVmsVmArgs) ToGetVmsVmOutput() GetVmsVmOutput {
	return i.ToGetVmsVmOutputWithContext(context.Background())
}

func (i GetVmsVmArgs) ToGetVmsVmOutputWithContext(ctx context.Context) GetVmsVmOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetVmsVmOutput)
}

// GetVmsVmArrayInput is an input type that accepts GetVmsVmArray and GetVmsVmArrayOutput values.
// You can construct a concrete instance of `GetVmsVmArrayInput` via:
//
//	GetVmsVmArray{ GetVmsVmArgs{...} }
type GetVmsVmArrayInput interface {
	pulumi.Input

	ToGetVmsVmArrayOutput() GetVmsVmArrayOutput
	ToGetVmsVmArrayOutputWithContext(context.Context) GetVmsVmArrayOutput
}

type GetVmsVmArray []GetVmsVmInput

func (GetVmsVmArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetVmsVm)(nil)).Elem()
}

func (i GetVmsVmArray) ToGetVmsVmArrayOutput() GetVmsVmArrayOutput {
	return i.ToGetVmsVmArrayOutputWithContext(context.Background())
}

func (i GetVmsVmArray) ToGetVmsVmArrayOutputWithContext(ctx context.Context) GetVmsVmArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetVmsVmArrayOutput)
}

type GetVmsVmOutput struct{ *pulumi.OutputState }

func (GetVmsVmOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetVmsVm)(nil)).Elem()
}

func (o GetVmsVmOutput) ToGetVmsVmOutput() GetVmsVmOutput {
	return o
}

func (o GetVmsVmOutput) ToGetVmsVmOutputWithContext(ctx context.Context) GetVmsVmOutput {
	return o
}

// The preferred host you would like the VM to run on. If changed on an existing VM it will require a reboot for the VM to be rescheduled.
func (o GetVmsVmOutput) AffinityHost() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetVmsVm) *string { return v.AffinityHost }).(pulumi.StringPtrOutput)
}

// If the VM will automatically turn on. Defaults to `false`.
func (o GetVmsVmOutput) AutoPoweron() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GetVmsVm) *bool { return v.AutoPoweron }).(pulumi.BoolPtrOutput)
}

// List of operations on a VM that are not permitted. Examples include: clean_reboot, clean_shutdown, hard_reboot, hard_shutdown, pause, shutdown, suspend, destroy. This can be used to prevent a VM from being destroyed. The entire list can be found here
func (o GetVmsVmOutput) BlockedOperations() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetVmsVm) []string { return v.BlockedOperations }).(pulumi.StringArrayOutput)
}

// The type of clone to perform for the VM. Possible values include `fast` or `full` and defaults to `fast`. In order to perform a `full` clone, the VM template must not be a disk template.
func (o GetVmsVmOutput) CloneType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetVmsVm) *string { return v.CloneType }).(pulumi.StringPtrOutput)
}

// The content of the cloud-init config to use. See the cloud init docs for more [information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).
func (o GetVmsVmOutput) CloudConfig() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetVmsVm) *string { return v.CloudConfig }).(pulumi.StringPtrOutput)
}

// The content of the cloud-init network configuration for the VM (uses [version 1](https://cloudinit.readthedocs.io/en/latest/topics/network-config-format-v1.html))
func (o GetVmsVmOutput) CloudNetworkConfig() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetVmsVm) *string { return v.CloudNetworkConfig }).(pulumi.StringPtrOutput)
}

func (o GetVmsVmOutput) CoreOs() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GetVmsVm) *bool { return v.CoreOs }).(pulumi.BoolPtrOutput)
}

func (o GetVmsVmOutput) CpuCap() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GetVmsVm) *int { return v.CpuCap }).(pulumi.IntPtrOutput)
}

func (o GetVmsVmOutput) CpuWeight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GetVmsVm) *int { return v.CpuWeight }).(pulumi.IntPtrOutput)
}

// The number of CPUs the VM will have. Updates to this field will cause a stop and start of the VM if the new CPU value is greater than the max CPU value. This can be determined with the following command:
func (o GetVmsVmOutput) Cpus() pulumi.IntOutput {
	return o.ApplyT(func(v GetVmsVm) int { return v.Cpus }).(pulumi.IntOutput)
}

// The disk the VM will have access to.
func (o GetVmsVmOutput) Disks() GetVmsVmDiskArrayOutput {
	return o.ApplyT(func(v GetVmsVm) []GetVmsVmDisk { return v.Disks }).(GetVmsVmDiskArrayOutput)
}

// Boolean parameter that allows a VM to use nested virtualization.
func (o GetVmsVmOutput) ExpNestedHvm() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GetVmsVm) *bool { return v.ExpNestedHvm }).(pulumi.BoolPtrOutput)
}

// The restart priority for the VM. Possible values are `best-effort`, `restart` and empty string (no restarts on failure. Defaults to empty string
func (o GetVmsVmOutput) HighAvailability() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetVmsVm) *string { return v.HighAvailability }).(pulumi.StringPtrOutput)
}

func (o GetVmsVmOutput) Host() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetVmsVm) *string { return v.Host }).(pulumi.StringPtrOutput)
}

// The firmware to use for the VM. Possible values are `bios` and `uefi`.
func (o GetVmsVmOutput) HvmBootFirmware() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetVmsVm) *string { return v.HvmBootFirmware }).(pulumi.StringPtrOutput)
}

func (o GetVmsVmOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetVmsVm) string { return v.Id }).(pulumi.StringOutput)
}

func (o GetVmsVmOutput) Ipv4Addresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetVmsVm) []string { return v.Ipv4Addresses }).(pulumi.StringArrayOutput)
}

// This is only accessible if guest-tools is installed in the VM and if `expectedIpCidr` is set on any network interfaces. This will contain a list of the ipv6 addresses across all network interfaces in order.
func (o GetVmsVmOutput) Ipv6Addresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetVmsVm) []string { return v.Ipv6Addresses }).(pulumi.StringArrayOutput)
}

// The amount of memory in bytes the VM will have. Updates to this field will case a stop and start of the VM if the new value is greater than the dynamic memory max. This can be determined with the following command:
func (o GetVmsVmOutput) MemoryMax() pulumi.IntOutput {
	return o.ApplyT(func(v GetVmsVm) int { return v.MemoryMax }).(pulumi.IntOutput)
}

// The description of the VM.
func (o GetVmsVmOutput) NameDescription() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetVmsVm) *string { return v.NameDescription }).(pulumi.StringPtrOutput)
}

// The name of the VM.
func (o GetVmsVmOutput) NameLabel() pulumi.StringOutput {
	return o.ApplyT(func(v GetVmsVm) string { return v.NameLabel }).(pulumi.StringOutput)
}

// The network for the VM.
func (o GetVmsVmOutput) Networks() GetVmsVmNetworkArrayOutput {
	return o.ApplyT(func(v GetVmsVm) []GetVmsVmNetwork { return v.Networks }).(GetVmsVmNetworkArrayOutput)
}

// The power state of the VM. This can be Running, Halted, Paused or Suspended.
func (o GetVmsVmOutput) PowerState() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetVmsVm) *string { return v.PowerState }).(pulumi.StringPtrOutput)
}

func (o GetVmsVmOutput) ResourceSet() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetVmsVm) *string { return v.ResourceSet }).(pulumi.StringPtrOutput)
}

// Number of seconds the VM should be delayed from starting.
func (o GetVmsVmOutput) StartDelay() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GetVmsVm) *int { return v.StartDelay }).(pulumi.IntPtrOutput)
}

// The tags (labels) applied to the given entity.
func (o GetVmsVmOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetVmsVm) []string { return v.Tags }).(pulumi.StringArrayOutput)
}

// The ID of the VM template to create the new VM from.
func (o GetVmsVmOutput) Template() pulumi.StringOutput {
	return o.ApplyT(func(v GetVmsVm) string { return v.Template }).(pulumi.StringOutput)
}

// The video adapter the VM should use. Possible values include std and cirrus.
func (o GetVmsVmOutput) Vga() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetVmsVm) *string { return v.Vga }).(pulumi.StringPtrOutput)
}

// The videoram option the VM should use. Possible values include 1, 2, 4, 8, 16
func (o GetVmsVmOutput) Videoram() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GetVmsVm) *int { return v.Videoram }).(pulumi.IntPtrOutput)
}

// The key value pairs to be populated in xenstore.
func (o GetVmsVmOutput) Xenstore() pulumi.StringMapOutput {
	return o.ApplyT(func(v GetVmsVm) map[string]string { return v.Xenstore }).(pulumi.StringMapOutput)
}

type GetVmsVmArrayOutput struct{ *pulumi.OutputState }

func (GetVmsVmArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetVmsVm)(nil)).Elem()
}

func (o GetVmsVmArrayOutput) ToGetVmsVmArrayOutput() GetVmsVmArrayOutput {
	return o
}

func (o GetVmsVmArrayOutput) ToGetVmsVmArrayOutputWithContext(ctx context.Context) GetVmsVmArrayOutput {
	return o
}

func (o GetVmsVmArrayOutput) Index(i pulumi.IntInput) GetVmsVmOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetVmsVm {
		return vs[0].([]GetVmsVm)[vs[1].(int)]
	}).(GetVmsVmOutput)
}

type GetVmsVmDisk struct {
	// Whether the device should be attached to the VM.
	Attached *bool `pulumi:"attached"`
	// The description for the disk
	NameDescription *string `pulumi:"nameDescription"`
	// The name for the disk
	NameLabel string `pulumi:"nameLabel"`
	// Indicates the order of the block device.
	Position string `pulumi:"position"`
	// The size in bytes for the disk.
	Size int `pulumi:"size"`
	// The storage repository ID to use.
	SrId  string `pulumi:"srId"`
	VbdId string `pulumi:"vbdId"`
	VdiId string `pulumi:"vdiId"`
}

// GetVmsVmDiskInput is an input type that accepts GetVmsVmDiskArgs and GetVmsVmDiskOutput values.
// You can construct a concrete instance of `GetVmsVmDiskInput` via:
//
//	GetVmsVmDiskArgs{...}
type GetVmsVmDiskInput interface {
	pulumi.Input

	ToGetVmsVmDiskOutput() GetVmsVmDiskOutput
	ToGetVmsVmDiskOutputWithContext(context.Context) GetVmsVmDiskOutput
}

type GetVmsVmDiskArgs struct {
	// Whether the device should be attached to the VM.
	Attached pulumi.BoolPtrInput `pulumi:"attached"`
	// The description for the disk
	NameDescription pulumi.StringPtrInput `pulumi:"nameDescription"`
	// The name for the disk
	NameLabel pulumi.StringInput `pulumi:"nameLabel"`
	// Indicates the order of the block device.
	Position pulumi.StringInput `pulumi:"position"`
	// The size in bytes for the disk.
	Size pulumi.IntInput `pulumi:"size"`
	// The storage repository ID to use.
	SrId  pulumi.StringInput `pulumi:"srId"`
	VbdId pulumi.StringInput `pulumi:"vbdId"`
	VdiId pulumi.StringInput `pulumi:"vdiId"`
}

func (GetVmsVmDiskArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetVmsVmDisk)(nil)).Elem()
}

func (i GetVmsVmDiskArgs) ToGetVmsVmDiskOutput() GetVmsVmDiskOutput {
	return i.ToGetVmsVmDiskOutputWithContext(context.Background())
}

func (i GetVmsVmDiskArgs) ToGetVmsVmDiskOutputWithContext(ctx context.Context) GetVmsVmDiskOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetVmsVmDiskOutput)
}

// GetVmsVmDiskArrayInput is an input type that accepts GetVmsVmDiskArray and GetVmsVmDiskArrayOutput values.
// You can construct a concrete instance of `GetVmsVmDiskArrayInput` via:
//
//	GetVmsVmDiskArray{ GetVmsVmDiskArgs{...} }
type GetVmsVmDiskArrayInput interface {
	pulumi.Input

	ToGetVmsVmDiskArrayOutput() GetVmsVmDiskArrayOutput
	ToGetVmsVmDiskArrayOutputWithContext(context.Context) GetVmsVmDiskArrayOutput
}

type GetVmsVmDiskArray []GetVmsVmDiskInput

func (GetVmsVmDiskArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetVmsVmDisk)(nil)).Elem()
}

func (i GetVmsVmDiskArray) ToGetVmsVmDiskArrayOutput() GetVmsVmDiskArrayOutput {
	return i.ToGetVmsVmDiskArrayOutputWithContext(context.Background())
}

func (i GetVmsVmDiskArray) ToGetVmsVmDiskArrayOutputWithContext(ctx context.Context) GetVmsVmDiskArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetVmsVmDiskArrayOutput)
}

type GetVmsVmDiskOutput struct{ *pulumi.OutputState }

func (GetVmsVmDiskOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetVmsVmDisk)(nil)).Elem()
}

func (o GetVmsVmDiskOutput) ToGetVmsVmDiskOutput() GetVmsVmDiskOutput {
	return o
}

func (o GetVmsVmDiskOutput) ToGetVmsVmDiskOutputWithContext(ctx context.Context) GetVmsVmDiskOutput {
	return o
}

// Whether the device should be attached to the VM.
func (o GetVmsVmDiskOutput) Attached() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GetVmsVmDisk) *bool { return v.Attached }).(pulumi.BoolPtrOutput)
}

// The description for the disk
func (o GetVmsVmDiskOutput) NameDescription() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetVmsVmDisk) *string { return v.NameDescription }).(pulumi.StringPtrOutput)
}

// The name for the disk
func (o GetVmsVmDiskOutput) NameLabel() pulumi.StringOutput {
	return o.ApplyT(func(v GetVmsVmDisk) string { return v.NameLabel }).(pulumi.StringOutput)
}

// Indicates the order of the block device.
func (o GetVmsVmDiskOutput) Position() pulumi.StringOutput {
	return o.ApplyT(func(v GetVmsVmDisk) string { return v.Position }).(pulumi.StringOutput)
}

// The size in bytes for the disk.
func (o GetVmsVmDiskOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v GetVmsVmDisk) int { return v.Size }).(pulumi.IntOutput)
}

// The storage repository ID to use.
func (o GetVmsVmDiskOutput) SrId() pulumi.StringOutput {
	return o.ApplyT(func(v GetVmsVmDisk) string { return v.SrId }).(pulumi.StringOutput)
}

func (o GetVmsVmDiskOutput) VbdId() pulumi.StringOutput {
	return o.ApplyT(func(v GetVmsVmDisk) string { return v.VbdId }).(pulumi.StringOutput)
}

func (o GetVmsVmDiskOutput) VdiId() pulumi.StringOutput {
	return o.ApplyT(func(v GetVmsVmDisk) string { return v.VdiId }).(pulumi.StringOutput)
}

type GetVmsVmDiskArrayOutput struct{ *pulumi.OutputState }

func (GetVmsVmDiskArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetVmsVmDisk)(nil)).Elem()
}

func (o GetVmsVmDiskArrayOutput) ToGetVmsVmDiskArrayOutput() GetVmsVmDiskArrayOutput {
	return o
}

func (o GetVmsVmDiskArrayOutput) ToGetVmsVmDiskArrayOutputWithContext(ctx context.Context) GetVmsVmDiskArrayOutput {
	return o
}

func (o GetVmsVmDiskArrayOutput) Index(i pulumi.IntInput) GetVmsVmDiskOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetVmsVmDisk {
		return vs[0].([]GetVmsVmDisk)[vs[1].(int)]
	}).(GetVmsVmDiskOutput)
}

type GetVmsVmNetwork struct {
	// Whether the device should be attached to the VM.
	Attached       *bool    `pulumi:"attached"`
	Device         string   `pulumi:"device"`
	ExpectedIpCidr *string  `pulumi:"expectedIpCidr"`
	Ipv4Addresses  []string `pulumi:"ipv4Addresses"`
	Ipv6Addresses  []string `pulumi:"ipv6Addresses"`
	MacAddress     string   `pulumi:"macAddress"`
	// The ID of the network the VM will be on.
	NetworkId string `pulumi:"networkId"`
}

// GetVmsVmNetworkInput is an input type that accepts GetVmsVmNetworkArgs and GetVmsVmNetworkOutput values.
// You can construct a concrete instance of `GetVmsVmNetworkInput` via:
//
//	GetVmsVmNetworkArgs{...}
type GetVmsVmNetworkInput interface {
	pulumi.Input

	ToGetVmsVmNetworkOutput() GetVmsVmNetworkOutput
	ToGetVmsVmNetworkOutputWithContext(context.Context) GetVmsVmNetworkOutput
}

type GetVmsVmNetworkArgs struct {
	// Whether the device should be attached to the VM.
	Attached       pulumi.BoolPtrInput     `pulumi:"attached"`
	Device         pulumi.StringInput      `pulumi:"device"`
	ExpectedIpCidr pulumi.StringPtrInput   `pulumi:"expectedIpCidr"`
	Ipv4Addresses  pulumi.StringArrayInput `pulumi:"ipv4Addresses"`
	Ipv6Addresses  pulumi.StringArrayInput `pulumi:"ipv6Addresses"`
	MacAddress     pulumi.StringInput      `pulumi:"macAddress"`
	// The ID of the network the VM will be on.
	NetworkId pulumi.StringInput `pulumi:"networkId"`
}

func (GetVmsVmNetworkArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetVmsVmNetwork)(nil)).Elem()
}

func (i GetVmsVmNetworkArgs) ToGetVmsVmNetworkOutput() GetVmsVmNetworkOutput {
	return i.ToGetVmsVmNetworkOutputWithContext(context.Background())
}

func (i GetVmsVmNetworkArgs) ToGetVmsVmNetworkOutputWithContext(ctx context.Context) GetVmsVmNetworkOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetVmsVmNetworkOutput)
}

// GetVmsVmNetworkArrayInput is an input type that accepts GetVmsVmNetworkArray and GetVmsVmNetworkArrayOutput values.
// You can construct a concrete instance of `GetVmsVmNetworkArrayInput` via:
//
//	GetVmsVmNetworkArray{ GetVmsVmNetworkArgs{...} }
type GetVmsVmNetworkArrayInput interface {
	pulumi.Input

	ToGetVmsVmNetworkArrayOutput() GetVmsVmNetworkArrayOutput
	ToGetVmsVmNetworkArrayOutputWithContext(context.Context) GetVmsVmNetworkArrayOutput
}

type GetVmsVmNetworkArray []GetVmsVmNetworkInput

func (GetVmsVmNetworkArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetVmsVmNetwork)(nil)).Elem()
}

func (i GetVmsVmNetworkArray) ToGetVmsVmNetworkArrayOutput() GetVmsVmNetworkArrayOutput {
	return i.ToGetVmsVmNetworkArrayOutputWithContext(context.Background())
}

func (i GetVmsVmNetworkArray) ToGetVmsVmNetworkArrayOutputWithContext(ctx context.Context) GetVmsVmNetworkArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetVmsVmNetworkArrayOutput)
}

type GetVmsVmNetworkOutput struct{ *pulumi.OutputState }

func (GetVmsVmNetworkOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetVmsVmNetwork)(nil)).Elem()
}

func (o GetVmsVmNetworkOutput) ToGetVmsVmNetworkOutput() GetVmsVmNetworkOutput {
	return o
}

func (o GetVmsVmNetworkOutput) ToGetVmsVmNetworkOutputWithContext(ctx context.Context) GetVmsVmNetworkOutput {
	return o
}

// Whether the device should be attached to the VM.
func (o GetVmsVmNetworkOutput) Attached() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GetVmsVmNetwork) *bool { return v.Attached }).(pulumi.BoolPtrOutput)
}

func (o GetVmsVmNetworkOutput) Device() pulumi.StringOutput {
	return o.ApplyT(func(v GetVmsVmNetwork) string { return v.Device }).(pulumi.StringOutput)
}

func (o GetVmsVmNetworkOutput) ExpectedIpCidr() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetVmsVmNetwork) *string { return v.ExpectedIpCidr }).(pulumi.StringPtrOutput)
}

func (o GetVmsVmNetworkOutput) Ipv4Addresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetVmsVmNetwork) []string { return v.Ipv4Addresses }).(pulumi.StringArrayOutput)
}

func (o GetVmsVmNetworkOutput) Ipv6Addresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetVmsVmNetwork) []string { return v.Ipv6Addresses }).(pulumi.StringArrayOutput)
}

func (o GetVmsVmNetworkOutput) MacAddress() pulumi.StringOutput {
	return o.ApplyT(func(v GetVmsVmNetwork) string { return v.MacAddress }).(pulumi.StringOutput)
}

// The ID of the network the VM will be on.
func (o GetVmsVmNetworkOutput) NetworkId() pulumi.StringOutput {
	return o.ApplyT(func(v GetVmsVmNetwork) string { return v.NetworkId }).(pulumi.StringOutput)
}

type GetVmsVmNetworkArrayOutput struct{ *pulumi.OutputState }

func (GetVmsVmNetworkArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetVmsVmNetwork)(nil)).Elem()
}

func (o GetVmsVmNetworkArrayOutput) ToGetVmsVmNetworkArrayOutput() GetVmsVmNetworkArrayOutput {
	return o
}

func (o GetVmsVmNetworkArrayOutput) ToGetVmsVmNetworkArrayOutputWithContext(ctx context.Context) GetVmsVmNetworkArrayOutput {
	return o
}

func (o GetVmsVmNetworkArrayOutput) Index(i pulumi.IntInput) GetVmsVmNetworkOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetVmsVmNetwork {
		return vs[0].([]GetVmsVmNetwork)[vs[1].(int)]
	}).(GetVmsVmNetworkOutput)
}

type GetXoaHostsHost struct {
	// CPU information about the host. The 'cores' key will contain the number of cpu cores and the 'sockets' key will contain the number of sockets.
	Cpus map[string]int `pulumi:"cpus"`
	Id   string         `pulumi:"id"`
	// The memory size of the host.
	Memory int `pulumi:"memory"`
	// The memory usage of the host.
	MemoryUsage int `pulumi:"memoryUsage"`
	// The name label of the host.
	NameLabel string `pulumi:"nameLabel"`
	// Id of the pool that the host belongs to.
	PoolId string `pulumi:"poolId"`
	// The tags (labels) applied to the given entity.
	Tags []string `pulumi:"tags"`
}

// GetXoaHostsHostInput is an input type that accepts GetXoaHostsHostArgs and GetXoaHostsHostOutput values.
// You can construct a concrete instance of `GetXoaHostsHostInput` via:
//
//	GetXoaHostsHostArgs{...}
type GetXoaHostsHostInput interface {
	pulumi.Input

	ToGetXoaHostsHostOutput() GetXoaHostsHostOutput
	ToGetXoaHostsHostOutputWithContext(context.Context) GetXoaHostsHostOutput
}

type GetXoaHostsHostArgs struct {
	// CPU information about the host. The 'cores' key will contain the number of cpu cores and the 'sockets' key will contain the number of sockets.
	Cpus pulumi.IntMapInput `pulumi:"cpus"`
	Id   pulumi.StringInput `pulumi:"id"`
	// The memory size of the host.
	Memory pulumi.IntInput `pulumi:"memory"`
	// The memory usage of the host.
	MemoryUsage pulumi.IntInput `pulumi:"memoryUsage"`
	// The name label of the host.
	NameLabel pulumi.StringInput `pulumi:"nameLabel"`
	// Id of the pool that the host belongs to.
	PoolId pulumi.StringInput `pulumi:"poolId"`
	// The tags (labels) applied to the given entity.
	Tags pulumi.StringArrayInput `pulumi:"tags"`
}

func (GetXoaHostsHostArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetXoaHostsHost)(nil)).Elem()
}

func (i GetXoaHostsHostArgs) ToGetXoaHostsHostOutput() GetXoaHostsHostOutput {
	return i.ToGetXoaHostsHostOutputWithContext(context.Background())
}

func (i GetXoaHostsHostArgs) ToGetXoaHostsHostOutputWithContext(ctx context.Context) GetXoaHostsHostOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetXoaHostsHostOutput)
}

// GetXoaHostsHostArrayInput is an input type that accepts GetXoaHostsHostArray and GetXoaHostsHostArrayOutput values.
// You can construct a concrete instance of `GetXoaHostsHostArrayInput` via:
//
//	GetXoaHostsHostArray{ GetXoaHostsHostArgs{...} }
type GetXoaHostsHostArrayInput interface {
	pulumi.Input

	ToGetXoaHostsHostArrayOutput() GetXoaHostsHostArrayOutput
	ToGetXoaHostsHostArrayOutputWithContext(context.Context) GetXoaHostsHostArrayOutput
}

type GetXoaHostsHostArray []GetXoaHostsHostInput

func (GetXoaHostsHostArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetXoaHostsHost)(nil)).Elem()
}

func (i GetXoaHostsHostArray) ToGetXoaHostsHostArrayOutput() GetXoaHostsHostArrayOutput {
	return i.ToGetXoaHostsHostArrayOutputWithContext(context.Background())
}

func (i GetXoaHostsHostArray) ToGetXoaHostsHostArrayOutputWithContext(ctx context.Context) GetXoaHostsHostArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetXoaHostsHostArrayOutput)
}

type GetXoaHostsHostOutput struct{ *pulumi.OutputState }

func (GetXoaHostsHostOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetXoaHostsHost)(nil)).Elem()
}

func (o GetXoaHostsHostOutput) ToGetXoaHostsHostOutput() GetXoaHostsHostOutput {
	return o
}

func (o GetXoaHostsHostOutput) ToGetXoaHostsHostOutputWithContext(ctx context.Context) GetXoaHostsHostOutput {
	return o
}

// CPU information about the host. The 'cores' key will contain the number of cpu cores and the 'sockets' key will contain the number of sockets.
func (o GetXoaHostsHostOutput) Cpus() pulumi.IntMapOutput {
	return o.ApplyT(func(v GetXoaHostsHost) map[string]int { return v.Cpus }).(pulumi.IntMapOutput)
}

func (o GetXoaHostsHostOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaHostsHost) string { return v.Id }).(pulumi.StringOutput)
}

// The memory size of the host.
func (o GetXoaHostsHostOutput) Memory() pulumi.IntOutput {
	return o.ApplyT(func(v GetXoaHostsHost) int { return v.Memory }).(pulumi.IntOutput)
}

// The memory usage of the host.
func (o GetXoaHostsHostOutput) MemoryUsage() pulumi.IntOutput {
	return o.ApplyT(func(v GetXoaHostsHost) int { return v.MemoryUsage }).(pulumi.IntOutput)
}

// The name label of the host.
func (o GetXoaHostsHostOutput) NameLabel() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaHostsHost) string { return v.NameLabel }).(pulumi.StringOutput)
}

// Id of the pool that the host belongs to.
func (o GetXoaHostsHostOutput) PoolId() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaHostsHost) string { return v.PoolId }).(pulumi.StringOutput)
}

// The tags (labels) applied to the given entity.
func (o GetXoaHostsHostOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetXoaHostsHost) []string { return v.Tags }).(pulumi.StringArrayOutput)
}

type GetXoaHostsHostArrayOutput struct{ *pulumi.OutputState }

func (GetXoaHostsHostArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetXoaHostsHost)(nil)).Elem()
}

func (o GetXoaHostsHostArrayOutput) ToGetXoaHostsHostArrayOutput() GetXoaHostsHostArrayOutput {
	return o
}

func (o GetXoaHostsHostArrayOutput) ToGetXoaHostsHostArrayOutputWithContext(ctx context.Context) GetXoaHostsHostArrayOutput {
	return o
}

func (o GetXoaHostsHostArrayOutput) Index(i pulumi.IntInput) GetXoaHostsHostOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetXoaHostsHost {
		return vs[0].([]GetXoaHostsHost)[vs[1].(int)]
	}).(GetXoaHostsHostOutput)
}

type GetXoaVmsVm struct {
	// The preferred host you would like the VM to run on. If changed on an existing VM it will require a reboot for the VM to be rescheduled.
	AffinityHost *string `pulumi:"affinityHost"`
	// If the VM will automatically turn on. Defaults to `false`.
	AutoPoweron *bool `pulumi:"autoPoweron"`
	// List of operations on a VM that are not permitted. Examples include: clean_reboot, clean_shutdown, hard_reboot, hard_shutdown, pause, shutdown, suspend, destroy. This can be used to prevent a VM from being destroyed. The entire list can be found here
	BlockedOperations []string `pulumi:"blockedOperations"`
	// The type of clone to perform for the VM. Possible values include `fast` or `full` and defaults to `fast`. In order to perform a `full` clone, the VM template must not be a disk template.
	CloneType *string `pulumi:"cloneType"`
	// The content of the cloud-init config to use. See the cloud init docs for more [information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).
	CloudConfig *string `pulumi:"cloudConfig"`
	// The content of the cloud-init network configuration for the VM (uses [version 1](https://cloudinit.readthedocs.io/en/latest/topics/network-config-format-v1.html))
	CloudNetworkConfig *string `pulumi:"cloudNetworkConfig"`
	CoreOs             *bool   `pulumi:"coreOs"`
	CpuCap             *int    `pulumi:"cpuCap"`
	CpuWeight          *int    `pulumi:"cpuWeight"`
	// The number of CPUs the VM will have. Updates to this field will cause a stop and start of the VM if the new CPU value is greater than the max CPU value. This can be determined with the following command:
	Cpus int `pulumi:"cpus"`
	// The disk the VM will have access to.
	Disks []GetXoaVmsVmDisk `pulumi:"disks"`
	// Boolean parameter that allows a VM to use nested virtualization.
	ExpNestedHvm *bool `pulumi:"expNestedHvm"`
	// The restart priority for the VM. Possible values are `best-effort`, `restart` and empty string (no restarts on failure. Defaults to empty string
	HighAvailability *string `pulumi:"highAvailability"`
	Host             *string `pulumi:"host"`
	// The firmware to use for the VM. Possible values are `bios` and `uefi`.
	HvmBootFirmware *string  `pulumi:"hvmBootFirmware"`
	Id              string   `pulumi:"id"`
	Ipv4Addresses   []string `pulumi:"ipv4Addresses"`
	// This is only accessible if guest-tools is installed in the VM and if `expectedIpCidr` is set on any network interfaces. This will contain a list of the ipv6 addresses across all network interfaces in order.
	Ipv6Addresses []string `pulumi:"ipv6Addresses"`
	// The amount of memory in bytes the VM will have. Updates to this field will case a stop and start of the VM if the new value is greater than the dynamic memory max. This can be determined with the following command:
	MemoryMax int `pulumi:"memoryMax"`
	// The description of the VM.
	NameDescription *string `pulumi:"nameDescription"`
	// The name of the VM.
	NameLabel string `pulumi:"nameLabel"`
	// The network for the VM.
	Networks []GetXoaVmsVmNetwork `pulumi:"networks"`
	// The power state of the VM. This can be Running, Halted, Paused or Suspended.
	PowerState  *string `pulumi:"powerState"`
	ResourceSet *string `pulumi:"resourceSet"`
	// Number of seconds the VM should be delayed from starting.
	StartDelay *int `pulumi:"startDelay"`
	// The tags (labels) applied to the given entity.
	Tags []string `pulumi:"tags"`
	// The ID of the VM template to create the new VM from.
	Template string `pulumi:"template"`
	// The video adapter the VM should use. Possible values include std and cirrus.
	Vga *string `pulumi:"vga"`
	// The videoram option the VM should use. Possible values include 1, 2, 4, 8, 16
	Videoram *int `pulumi:"videoram"`
	// The key value pairs to be populated in xenstore.
	Xenstore map[string]string `pulumi:"xenstore"`
}

// GetXoaVmsVmInput is an input type that accepts GetXoaVmsVmArgs and GetXoaVmsVmOutput values.
// You can construct a concrete instance of `GetXoaVmsVmInput` via:
//
//	GetXoaVmsVmArgs{...}
type GetXoaVmsVmInput interface {
	pulumi.Input

	ToGetXoaVmsVmOutput() GetXoaVmsVmOutput
	ToGetXoaVmsVmOutputWithContext(context.Context) GetXoaVmsVmOutput
}

type GetXoaVmsVmArgs struct {
	// The preferred host you would like the VM to run on. If changed on an existing VM it will require a reboot for the VM to be rescheduled.
	AffinityHost pulumi.StringPtrInput `pulumi:"affinityHost"`
	// If the VM will automatically turn on. Defaults to `false`.
	AutoPoweron pulumi.BoolPtrInput `pulumi:"autoPoweron"`
	// List of operations on a VM that are not permitted. Examples include: clean_reboot, clean_shutdown, hard_reboot, hard_shutdown, pause, shutdown, suspend, destroy. This can be used to prevent a VM from being destroyed. The entire list can be found here
	BlockedOperations pulumi.StringArrayInput `pulumi:"blockedOperations"`
	// The type of clone to perform for the VM. Possible values include `fast` or `full` and defaults to `fast`. In order to perform a `full` clone, the VM template must not be a disk template.
	CloneType pulumi.StringPtrInput `pulumi:"cloneType"`
	// The content of the cloud-init config to use. See the cloud init docs for more [information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).
	CloudConfig pulumi.StringPtrInput `pulumi:"cloudConfig"`
	// The content of the cloud-init network configuration for the VM (uses [version 1](https://cloudinit.readthedocs.io/en/latest/topics/network-config-format-v1.html))
	CloudNetworkConfig pulumi.StringPtrInput `pulumi:"cloudNetworkConfig"`
	CoreOs             pulumi.BoolPtrInput   `pulumi:"coreOs"`
	CpuCap             pulumi.IntPtrInput    `pulumi:"cpuCap"`
	CpuWeight          pulumi.IntPtrInput    `pulumi:"cpuWeight"`
	// The number of CPUs the VM will have. Updates to this field will cause a stop and start of the VM if the new CPU value is greater than the max CPU value. This can be determined with the following command:
	Cpus pulumi.IntInput `pulumi:"cpus"`
	// The disk the VM will have access to.
	Disks GetXoaVmsVmDiskArrayInput `pulumi:"disks"`
	// Boolean parameter that allows a VM to use nested virtualization.
	ExpNestedHvm pulumi.BoolPtrInput `pulumi:"expNestedHvm"`
	// The restart priority for the VM. Possible values are `best-effort`, `restart` and empty string (no restarts on failure. Defaults to empty string
	HighAvailability pulumi.StringPtrInput `pulumi:"highAvailability"`
	Host             pulumi.StringPtrInput `pulumi:"host"`
	// The firmware to use for the VM. Possible values are `bios` and `uefi`.
	HvmBootFirmware pulumi.StringPtrInput   `pulumi:"hvmBootFirmware"`
	Id              pulumi.StringInput      `pulumi:"id"`
	Ipv4Addresses   pulumi.StringArrayInput `pulumi:"ipv4Addresses"`
	// This is only accessible if guest-tools is installed in the VM and if `expectedIpCidr` is set on any network interfaces. This will contain a list of the ipv6 addresses across all network interfaces in order.
	Ipv6Addresses pulumi.StringArrayInput `pulumi:"ipv6Addresses"`
	// The amount of memory in bytes the VM will have. Updates to this field will case a stop and start of the VM if the new value is greater than the dynamic memory max. This can be determined with the following command:
	MemoryMax pulumi.IntInput `pulumi:"memoryMax"`
	// The description of the VM.
	NameDescription pulumi.StringPtrInput `pulumi:"nameDescription"`
	// The name of the VM.
	NameLabel pulumi.StringInput `pulumi:"nameLabel"`
	// The network for the VM.
	Networks GetXoaVmsVmNetworkArrayInput `pulumi:"networks"`
	// The power state of the VM. This can be Running, Halted, Paused or Suspended.
	PowerState  pulumi.StringPtrInput `pulumi:"powerState"`
	ResourceSet pulumi.StringPtrInput `pulumi:"resourceSet"`
	// Number of seconds the VM should be delayed from starting.
	StartDelay pulumi.IntPtrInput `pulumi:"startDelay"`
	// The tags (labels) applied to the given entity.
	Tags pulumi.StringArrayInput `pulumi:"tags"`
	// The ID of the VM template to create the new VM from.
	Template pulumi.StringInput `pulumi:"template"`
	// The video adapter the VM should use. Possible values include std and cirrus.
	Vga pulumi.StringPtrInput `pulumi:"vga"`
	// The videoram option the VM should use. Possible values include 1, 2, 4, 8, 16
	Videoram pulumi.IntPtrInput `pulumi:"videoram"`
	// The key value pairs to be populated in xenstore.
	Xenstore pulumi.StringMapInput `pulumi:"xenstore"`
}

func (GetXoaVmsVmArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetXoaVmsVm)(nil)).Elem()
}

func (i GetXoaVmsVmArgs) ToGetXoaVmsVmOutput() GetXoaVmsVmOutput {
	return i.ToGetXoaVmsVmOutputWithContext(context.Background())
}

func (i GetXoaVmsVmArgs) ToGetXoaVmsVmOutputWithContext(ctx context.Context) GetXoaVmsVmOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetXoaVmsVmOutput)
}

// GetXoaVmsVmArrayInput is an input type that accepts GetXoaVmsVmArray and GetXoaVmsVmArrayOutput values.
// You can construct a concrete instance of `GetXoaVmsVmArrayInput` via:
//
//	GetXoaVmsVmArray{ GetXoaVmsVmArgs{...} }
type GetXoaVmsVmArrayInput interface {
	pulumi.Input

	ToGetXoaVmsVmArrayOutput() GetXoaVmsVmArrayOutput
	ToGetXoaVmsVmArrayOutputWithContext(context.Context) GetXoaVmsVmArrayOutput
}

type GetXoaVmsVmArray []GetXoaVmsVmInput

func (GetXoaVmsVmArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetXoaVmsVm)(nil)).Elem()
}

func (i GetXoaVmsVmArray) ToGetXoaVmsVmArrayOutput() GetXoaVmsVmArrayOutput {
	return i.ToGetXoaVmsVmArrayOutputWithContext(context.Background())
}

func (i GetXoaVmsVmArray) ToGetXoaVmsVmArrayOutputWithContext(ctx context.Context) GetXoaVmsVmArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetXoaVmsVmArrayOutput)
}

type GetXoaVmsVmOutput struct{ *pulumi.OutputState }

func (GetXoaVmsVmOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetXoaVmsVm)(nil)).Elem()
}

func (o GetXoaVmsVmOutput) ToGetXoaVmsVmOutput() GetXoaVmsVmOutput {
	return o
}

func (o GetXoaVmsVmOutput) ToGetXoaVmsVmOutputWithContext(ctx context.Context) GetXoaVmsVmOutput {
	return o
}

// The preferred host you would like the VM to run on. If changed on an existing VM it will require a reboot for the VM to be rescheduled.
func (o GetXoaVmsVmOutput) AffinityHost() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *string { return v.AffinityHost }).(pulumi.StringPtrOutput)
}

// If the VM will automatically turn on. Defaults to `false`.
func (o GetXoaVmsVmOutput) AutoPoweron() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *bool { return v.AutoPoweron }).(pulumi.BoolPtrOutput)
}

// List of operations on a VM that are not permitted. Examples include: clean_reboot, clean_shutdown, hard_reboot, hard_shutdown, pause, shutdown, suspend, destroy. This can be used to prevent a VM from being destroyed. The entire list can be found here
func (o GetXoaVmsVmOutput) BlockedOperations() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetXoaVmsVm) []string { return v.BlockedOperations }).(pulumi.StringArrayOutput)
}

// The type of clone to perform for the VM. Possible values include `fast` or `full` and defaults to `fast`. In order to perform a `full` clone, the VM template must not be a disk template.
func (o GetXoaVmsVmOutput) CloneType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *string { return v.CloneType }).(pulumi.StringPtrOutput)
}

// The content of the cloud-init config to use. See the cloud init docs for more [information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).
func (o GetXoaVmsVmOutput) CloudConfig() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *string { return v.CloudConfig }).(pulumi.StringPtrOutput)
}

// The content of the cloud-init network configuration for the VM (uses [version 1](https://cloudinit.readthedocs.io/en/latest/topics/network-config-format-v1.html))
func (o GetXoaVmsVmOutput) CloudNetworkConfig() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *string { return v.CloudNetworkConfig }).(pulumi.StringPtrOutput)
}

func (o GetXoaVmsVmOutput) CoreOs() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *bool { return v.CoreOs }).(pulumi.BoolPtrOutput)
}

func (o GetXoaVmsVmOutput) CpuCap() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *int { return v.CpuCap }).(pulumi.IntPtrOutput)
}

func (o GetXoaVmsVmOutput) CpuWeight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *int { return v.CpuWeight }).(pulumi.IntPtrOutput)
}

// The number of CPUs the VM will have. Updates to this field will cause a stop and start of the VM if the new CPU value is greater than the max CPU value. This can be determined with the following command:
func (o GetXoaVmsVmOutput) Cpus() pulumi.IntOutput {
	return o.ApplyT(func(v GetXoaVmsVm) int { return v.Cpus }).(pulumi.IntOutput)
}

// The disk the VM will have access to.
func (o GetXoaVmsVmOutput) Disks() GetXoaVmsVmDiskArrayOutput {
	return o.ApplyT(func(v GetXoaVmsVm) []GetXoaVmsVmDisk { return v.Disks }).(GetXoaVmsVmDiskArrayOutput)
}

// Boolean parameter that allows a VM to use nested virtualization.
func (o GetXoaVmsVmOutput) ExpNestedHvm() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *bool { return v.ExpNestedHvm }).(pulumi.BoolPtrOutput)
}

// The restart priority for the VM. Possible values are `best-effort`, `restart` and empty string (no restarts on failure. Defaults to empty string
func (o GetXoaVmsVmOutput) HighAvailability() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *string { return v.HighAvailability }).(pulumi.StringPtrOutput)
}

func (o GetXoaVmsVmOutput) Host() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *string { return v.Host }).(pulumi.StringPtrOutput)
}

// The firmware to use for the VM. Possible values are `bios` and `uefi`.
func (o GetXoaVmsVmOutput) HvmBootFirmware() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *string { return v.HvmBootFirmware }).(pulumi.StringPtrOutput)
}

func (o GetXoaVmsVmOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaVmsVm) string { return v.Id }).(pulumi.StringOutput)
}

func (o GetXoaVmsVmOutput) Ipv4Addresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetXoaVmsVm) []string { return v.Ipv4Addresses }).(pulumi.StringArrayOutput)
}

// This is only accessible if guest-tools is installed in the VM and if `expectedIpCidr` is set on any network interfaces. This will contain a list of the ipv6 addresses across all network interfaces in order.
func (o GetXoaVmsVmOutput) Ipv6Addresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetXoaVmsVm) []string { return v.Ipv6Addresses }).(pulumi.StringArrayOutput)
}

// The amount of memory in bytes the VM will have. Updates to this field will case a stop and start of the VM if the new value is greater than the dynamic memory max. This can be determined with the following command:
func (o GetXoaVmsVmOutput) MemoryMax() pulumi.IntOutput {
	return o.ApplyT(func(v GetXoaVmsVm) int { return v.MemoryMax }).(pulumi.IntOutput)
}

// The description of the VM.
func (o GetXoaVmsVmOutput) NameDescription() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *string { return v.NameDescription }).(pulumi.StringPtrOutput)
}

// The name of the VM.
func (o GetXoaVmsVmOutput) NameLabel() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaVmsVm) string { return v.NameLabel }).(pulumi.StringOutput)
}

// The network for the VM.
func (o GetXoaVmsVmOutput) Networks() GetXoaVmsVmNetworkArrayOutput {
	return o.ApplyT(func(v GetXoaVmsVm) []GetXoaVmsVmNetwork { return v.Networks }).(GetXoaVmsVmNetworkArrayOutput)
}

// The power state of the VM. This can be Running, Halted, Paused or Suspended.
func (o GetXoaVmsVmOutput) PowerState() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *string { return v.PowerState }).(pulumi.StringPtrOutput)
}

func (o GetXoaVmsVmOutput) ResourceSet() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *string { return v.ResourceSet }).(pulumi.StringPtrOutput)
}

// Number of seconds the VM should be delayed from starting.
func (o GetXoaVmsVmOutput) StartDelay() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *int { return v.StartDelay }).(pulumi.IntPtrOutput)
}

// The tags (labels) applied to the given entity.
func (o GetXoaVmsVmOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetXoaVmsVm) []string { return v.Tags }).(pulumi.StringArrayOutput)
}

// The ID of the VM template to create the new VM from.
func (o GetXoaVmsVmOutput) Template() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaVmsVm) string { return v.Template }).(pulumi.StringOutput)
}

// The video adapter the VM should use. Possible values include std and cirrus.
func (o GetXoaVmsVmOutput) Vga() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *string { return v.Vga }).(pulumi.StringPtrOutput)
}

// The videoram option the VM should use. Possible values include 1, 2, 4, 8, 16
func (o GetXoaVmsVmOutput) Videoram() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *int { return v.Videoram }).(pulumi.IntPtrOutput)
}

// The key value pairs to be populated in xenstore.
func (o GetXoaVmsVmOutput) Xenstore() pulumi.StringMapOutput {
	return o.ApplyT(func(v GetXoaVmsVm) map[string]string { return v.Xenstore }).(pulumi.StringMapOutput)
}

type GetXoaVmsVmArrayOutput struct{ *pulumi.OutputState }

func (GetXoaVmsVmArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetXoaVmsVm)(nil)).Elem()
}

func (o GetXoaVmsVmArrayOutput) ToGetXoaVmsVmArrayOutput() GetXoaVmsVmArrayOutput {
	return o
}

func (o GetXoaVmsVmArrayOutput) ToGetXoaVmsVmArrayOutputWithContext(ctx context.Context) GetXoaVmsVmArrayOutput {
	return o
}

func (o GetXoaVmsVmArrayOutput) Index(i pulumi.IntInput) GetXoaVmsVmOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetXoaVmsVm {
		return vs[0].([]GetXoaVmsVm)[vs[1].(int)]
	}).(GetXoaVmsVmOutput)
}

type GetXoaVmsVmDisk struct {
	// Whether the device should be attached to the VM.
	Attached *bool `pulumi:"attached"`
	// The description for the disk
	NameDescription *string `pulumi:"nameDescription"`
	// The name for the disk
	NameLabel string `pulumi:"nameLabel"`
	// Indicates the order of the block device.
	Position string `pulumi:"position"`
	// The size in bytes for the disk.
	Size int `pulumi:"size"`
	// The storage repository ID to use.
	SrId  string `pulumi:"srId"`
	VbdId string `pulumi:"vbdId"`
	VdiId string `pulumi:"vdiId"`
}

// GetXoaVmsVmDiskInput is an input type that accepts GetXoaVmsVmDiskArgs and GetXoaVmsVmDiskOutput values.
// You can construct a concrete instance of `GetXoaVmsVmDiskInput` via:
//
//	GetXoaVmsVmDiskArgs{...}
type GetXoaVmsVmDiskInput interface {
	pulumi.Input

	ToGetXoaVmsVmDiskOutput() GetXoaVmsVmDiskOutput
	ToGetXoaVmsVmDiskOutputWithContext(context.Context) GetXoaVmsVmDiskOutput
}

type GetXoaVmsVmDiskArgs struct {
	// Whether the device should be attached to the VM.
	Attached pulumi.BoolPtrInput `pulumi:"attached"`
	// The description for the disk
	NameDescription pulumi.StringPtrInput `pulumi:"nameDescription"`
	// The name for the disk
	NameLabel pulumi.StringInput `pulumi:"nameLabel"`
	// Indicates the order of the block device.
	Position pulumi.StringInput `pulumi:"position"`
	// The size in bytes for the disk.
	Size pulumi.IntInput `pulumi:"size"`
	// The storage repository ID to use.
	SrId  pulumi.StringInput `pulumi:"srId"`
	VbdId pulumi.StringInput `pulumi:"vbdId"`
	VdiId pulumi.StringInput `pulumi:"vdiId"`
}

func (GetXoaVmsVmDiskArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetXoaVmsVmDisk)(nil)).Elem()
}

func (i GetXoaVmsVmDiskArgs) ToGetXoaVmsVmDiskOutput() GetXoaVmsVmDiskOutput {
	return i.ToGetXoaVmsVmDiskOutputWithContext(context.Background())
}

func (i GetXoaVmsVmDiskArgs) ToGetXoaVmsVmDiskOutputWithContext(ctx context.Context) GetXoaVmsVmDiskOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetXoaVmsVmDiskOutput)
}

// GetXoaVmsVmDiskArrayInput is an input type that accepts GetXoaVmsVmDiskArray and GetXoaVmsVmDiskArrayOutput values.
// You can construct a concrete instance of `GetXoaVmsVmDiskArrayInput` via:
//
//	GetXoaVmsVmDiskArray{ GetXoaVmsVmDiskArgs{...} }
type GetXoaVmsVmDiskArrayInput interface {
	pulumi.Input

	ToGetXoaVmsVmDiskArrayOutput() GetXoaVmsVmDiskArrayOutput
	ToGetXoaVmsVmDiskArrayOutputWithContext(context.Context) GetXoaVmsVmDiskArrayOutput
}

type GetXoaVmsVmDiskArray []GetXoaVmsVmDiskInput

func (GetXoaVmsVmDiskArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetXoaVmsVmDisk)(nil)).Elem()
}

func (i GetXoaVmsVmDiskArray) ToGetXoaVmsVmDiskArrayOutput() GetXoaVmsVmDiskArrayOutput {
	return i.ToGetXoaVmsVmDiskArrayOutputWithContext(context.Background())
}

func (i GetXoaVmsVmDiskArray) ToGetXoaVmsVmDiskArrayOutputWithContext(ctx context.Context) GetXoaVmsVmDiskArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetXoaVmsVmDiskArrayOutput)
}

type GetXoaVmsVmDiskOutput struct{ *pulumi.OutputState }

func (GetXoaVmsVmDiskOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetXoaVmsVmDisk)(nil)).Elem()
}

func (o GetXoaVmsVmDiskOutput) ToGetXoaVmsVmDiskOutput() GetXoaVmsVmDiskOutput {
	return o
}

func (o GetXoaVmsVmDiskOutput) ToGetXoaVmsVmDiskOutputWithContext(ctx context.Context) GetXoaVmsVmDiskOutput {
	return o
}

// Whether the device should be attached to the VM.
func (o GetXoaVmsVmDiskOutput) Attached() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVmDisk) *bool { return v.Attached }).(pulumi.BoolPtrOutput)
}

// The description for the disk
func (o GetXoaVmsVmDiskOutput) NameDescription() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVmDisk) *string { return v.NameDescription }).(pulumi.StringPtrOutput)
}

// The name for the disk
func (o GetXoaVmsVmDiskOutput) NameLabel() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaVmsVmDisk) string { return v.NameLabel }).(pulumi.StringOutput)
}

// Indicates the order of the block device.
func (o GetXoaVmsVmDiskOutput) Position() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaVmsVmDisk) string { return v.Position }).(pulumi.StringOutput)
}

// The size in bytes for the disk.
func (o GetXoaVmsVmDiskOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v GetXoaVmsVmDisk) int { return v.Size }).(pulumi.IntOutput)
}

// The storage repository ID to use.
func (o GetXoaVmsVmDiskOutput) SrId() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaVmsVmDisk) string { return v.SrId }).(pulumi.StringOutput)
}

func (o GetXoaVmsVmDiskOutput) VbdId() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaVmsVmDisk) string { return v.VbdId }).(pulumi.StringOutput)
}

func (o GetXoaVmsVmDiskOutput) VdiId() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaVmsVmDisk) string { return v.VdiId }).(pulumi.StringOutput)
}

type GetXoaVmsVmDiskArrayOutput struct{ *pulumi.OutputState }

func (GetXoaVmsVmDiskArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetXoaVmsVmDisk)(nil)).Elem()
}

func (o GetXoaVmsVmDiskArrayOutput) ToGetXoaVmsVmDiskArrayOutput() GetXoaVmsVmDiskArrayOutput {
	return o
}

func (o GetXoaVmsVmDiskArrayOutput) ToGetXoaVmsVmDiskArrayOutputWithContext(ctx context.Context) GetXoaVmsVmDiskArrayOutput {
	return o
}

func (o GetXoaVmsVmDiskArrayOutput) Index(i pulumi.IntInput) GetXoaVmsVmDiskOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetXoaVmsVmDisk {
		return vs[0].([]GetXoaVmsVmDisk)[vs[1].(int)]
	}).(GetXoaVmsVmDiskOutput)
}

type GetXoaVmsVmNetwork struct {
	// Whether the device should be attached to the VM.
	Attached       *bool    `pulumi:"attached"`
	Device         string   `pulumi:"device"`
	ExpectedIpCidr *string  `pulumi:"expectedIpCidr"`
	Ipv4Addresses  []string `pulumi:"ipv4Addresses"`
	Ipv6Addresses  []string `pulumi:"ipv6Addresses"`
	MacAddress     string   `pulumi:"macAddress"`
	// The ID of the network the VM will be on.
	NetworkId string `pulumi:"networkId"`
}

// GetXoaVmsVmNetworkInput is an input type that accepts GetXoaVmsVmNetworkArgs and GetXoaVmsVmNetworkOutput values.
// You can construct a concrete instance of `GetXoaVmsVmNetworkInput` via:
//
//	GetXoaVmsVmNetworkArgs{...}
type GetXoaVmsVmNetworkInput interface {
	pulumi.Input

	ToGetXoaVmsVmNetworkOutput() GetXoaVmsVmNetworkOutput
	ToGetXoaVmsVmNetworkOutputWithContext(context.Context) GetXoaVmsVmNetworkOutput
}

type GetXoaVmsVmNetworkArgs struct {
	// Whether the device should be attached to the VM.
	Attached       pulumi.BoolPtrInput     `pulumi:"attached"`
	Device         pulumi.StringInput      `pulumi:"device"`
	ExpectedIpCidr pulumi.StringPtrInput   `pulumi:"expectedIpCidr"`
	Ipv4Addresses  pulumi.StringArrayInput `pulumi:"ipv4Addresses"`
	Ipv6Addresses  pulumi.StringArrayInput `pulumi:"ipv6Addresses"`
	MacAddress     pulumi.StringInput      `pulumi:"macAddress"`
	// The ID of the network the VM will be on.
	NetworkId pulumi.StringInput `pulumi:"networkId"`
}

func (GetXoaVmsVmNetworkArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetXoaVmsVmNetwork)(nil)).Elem()
}

func (i GetXoaVmsVmNetworkArgs) ToGetXoaVmsVmNetworkOutput() GetXoaVmsVmNetworkOutput {
	return i.ToGetXoaVmsVmNetworkOutputWithContext(context.Background())
}

func (i GetXoaVmsVmNetworkArgs) ToGetXoaVmsVmNetworkOutputWithContext(ctx context.Context) GetXoaVmsVmNetworkOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetXoaVmsVmNetworkOutput)
}

// GetXoaVmsVmNetworkArrayInput is an input type that accepts GetXoaVmsVmNetworkArray and GetXoaVmsVmNetworkArrayOutput values.
// You can construct a concrete instance of `GetXoaVmsVmNetworkArrayInput` via:
//
//	GetXoaVmsVmNetworkArray{ GetXoaVmsVmNetworkArgs{...} }
type GetXoaVmsVmNetworkArrayInput interface {
	pulumi.Input

	ToGetXoaVmsVmNetworkArrayOutput() GetXoaVmsVmNetworkArrayOutput
	ToGetXoaVmsVmNetworkArrayOutputWithContext(context.Context) GetXoaVmsVmNetworkArrayOutput
}

type GetXoaVmsVmNetworkArray []GetXoaVmsVmNetworkInput

func (GetXoaVmsVmNetworkArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetXoaVmsVmNetwork)(nil)).Elem()
}

func (i GetXoaVmsVmNetworkArray) ToGetXoaVmsVmNetworkArrayOutput() GetXoaVmsVmNetworkArrayOutput {
	return i.ToGetXoaVmsVmNetworkArrayOutputWithContext(context.Background())
}

func (i GetXoaVmsVmNetworkArray) ToGetXoaVmsVmNetworkArrayOutputWithContext(ctx context.Context) GetXoaVmsVmNetworkArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetXoaVmsVmNetworkArrayOutput)
}

type GetXoaVmsVmNetworkOutput struct{ *pulumi.OutputState }

func (GetXoaVmsVmNetworkOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetXoaVmsVmNetwork)(nil)).Elem()
}

func (o GetXoaVmsVmNetworkOutput) ToGetXoaVmsVmNetworkOutput() GetXoaVmsVmNetworkOutput {
	return o
}

func (o GetXoaVmsVmNetworkOutput) ToGetXoaVmsVmNetworkOutputWithContext(ctx context.Context) GetXoaVmsVmNetworkOutput {
	return o
}

// Whether the device should be attached to the VM.
func (o GetXoaVmsVmNetworkOutput) Attached() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVmNetwork) *bool { return v.Attached }).(pulumi.BoolPtrOutput)
}

func (o GetXoaVmsVmNetworkOutput) Device() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaVmsVmNetwork) string { return v.Device }).(pulumi.StringOutput)
}

func (o GetXoaVmsVmNetworkOutput) ExpectedIpCidr() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVmNetwork) *string { return v.ExpectedIpCidr }).(pulumi.StringPtrOutput)
}

func (o GetXoaVmsVmNetworkOutput) Ipv4Addresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetXoaVmsVmNetwork) []string { return v.Ipv4Addresses }).(pulumi.StringArrayOutput)
}

func (o GetXoaVmsVmNetworkOutput) Ipv6Addresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetXoaVmsVmNetwork) []string { return v.Ipv6Addresses }).(pulumi.StringArrayOutput)
}

func (o GetXoaVmsVmNetworkOutput) MacAddress() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaVmsVmNetwork) string { return v.MacAddress }).(pulumi.StringOutput)
}

// The ID of the network the VM will be on.
func (o GetXoaVmsVmNetworkOutput) NetworkId() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaVmsVmNetwork) string { return v.NetworkId }).(pulumi.StringOutput)
}

type GetXoaVmsVmNetworkArrayOutput struct{ *pulumi.OutputState }

func (GetXoaVmsVmNetworkArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetXoaVmsVmNetwork)(nil)).Elem()
}

func (o GetXoaVmsVmNetworkArrayOutput) ToGetXoaVmsVmNetworkArrayOutput() GetXoaVmsVmNetworkArrayOutput {
	return o
}

func (o GetXoaVmsVmNetworkArrayOutput) ToGetXoaVmsVmNetworkArrayOutputWithContext(ctx context.Context) GetXoaVmsVmNetworkArrayOutput {
	return o
}

func (o GetXoaVmsVmNetworkArrayOutput) Index(i pulumi.IntInput) GetXoaVmsVmNetworkOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetXoaVmsVmNetwork {
		return vs[0].([]GetXoaVmsVmNetwork)[vs[1].(int)]
	}).(GetXoaVmsVmNetworkOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceSetLimitInput)(nil)).Elem(), ResourceSetLimitArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceSetLimitArrayInput)(nil)).Elem(), ResourceSetLimitArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VmCdromInput)(nil)).Elem(), VmCdromArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VmCdromPtrInput)(nil)).Elem(), VmCdromArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VmDiskInput)(nil)).Elem(), VmDiskArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VmDiskArrayInput)(nil)).Elem(), VmDiskArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VmNetworkInput)(nil)).Elem(), VmNetworkArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VmNetworkArrayInput)(nil)).Elem(), VmNetworkArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetHostsHostInput)(nil)).Elem(), GetHostsHostArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetHostsHostArrayInput)(nil)).Elem(), GetHostsHostArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetVmsVmInput)(nil)).Elem(), GetVmsVmArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetVmsVmArrayInput)(nil)).Elem(), GetVmsVmArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetVmsVmDiskInput)(nil)).Elem(), GetVmsVmDiskArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetVmsVmDiskArrayInput)(nil)).Elem(), GetVmsVmDiskArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetVmsVmNetworkInput)(nil)).Elem(), GetVmsVmNetworkArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetVmsVmNetworkArrayInput)(nil)).Elem(), GetVmsVmNetworkArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetXoaHostsHostInput)(nil)).Elem(), GetXoaHostsHostArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetXoaHostsHostArrayInput)(nil)).Elem(), GetXoaHostsHostArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetXoaVmsVmInput)(nil)).Elem(), GetXoaVmsVmArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetXoaVmsVmArrayInput)(nil)).Elem(), GetXoaVmsVmArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetXoaVmsVmDiskInput)(nil)).Elem(), GetXoaVmsVmDiskArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetXoaVmsVmDiskArrayInput)(nil)).Elem(), GetXoaVmsVmDiskArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetXoaVmsVmNetworkInput)(nil)).Elem(), GetXoaVmsVmNetworkArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetXoaVmsVmNetworkArrayInput)(nil)).Elem(), GetXoaVmsVmNetworkArray{})
	pulumi.RegisterOutputType(ResourceSetLimitOutput{})
	pulumi.RegisterOutputType(ResourceSetLimitArrayOutput{})
	pulumi.RegisterOutputType(VmCdromOutput{})
	pulumi.RegisterOutputType(VmCdromPtrOutput{})
	pulumi.RegisterOutputType(VmDiskOutput{})
	pulumi.RegisterOutputType(VmDiskArrayOutput{})
	pulumi.RegisterOutputType(VmNetworkOutput{})
	pulumi.RegisterOutputType(VmNetworkArrayOutput{})
	pulumi.RegisterOutputType(GetHostsHostOutput{})
	pulumi.RegisterOutputType(GetHostsHostArrayOutput{})
	pulumi.RegisterOutputType(GetVmsVmOutput{})
	pulumi.RegisterOutputType(GetVmsVmArrayOutput{})
	pulumi.RegisterOutputType(GetVmsVmDiskOutput{})
	pulumi.RegisterOutputType(GetVmsVmDiskArrayOutput{})
	pulumi.RegisterOutputType(GetVmsVmNetworkOutput{})
	pulumi.RegisterOutputType(GetVmsVmNetworkArrayOutput{})
	pulumi.RegisterOutputType(GetXoaHostsHostOutput{})
	pulumi.RegisterOutputType(GetXoaHostsHostArrayOutput{})
	pulumi.RegisterOutputType(GetXoaVmsVmOutput{})
	pulumi.RegisterOutputType(GetXoaVmsVmArrayOutput{})
	pulumi.RegisterOutputType(GetXoaVmsVmDiskOutput{})
	pulumi.RegisterOutputType(GetXoaVmsVmDiskArrayOutput{})
	pulumi.RegisterOutputType(GetXoaVmsVmNetworkOutput{})
	pulumi.RegisterOutputType(GetXoaVmsVmNetworkArrayOutput{})
}
