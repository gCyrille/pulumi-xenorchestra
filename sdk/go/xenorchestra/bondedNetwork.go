// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package xenorchestra

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/vatesfr/pulumi-xenorchestra/sdk/go/xenorchestra/internal"
)

// A resource for managing Bonded Xen Orchestra networks. See the XCP-ng [networking docs](https://xcp-ng.org/docs/networking.html) for more details.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/vatesfr/pulumi-xenorchestra/sdk/go/xenorchestra"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			host1, err := xenorchestra.GetXoaHost(ctx, &xenorchestra.GetXoaHostArgs{
//				NameLabel: "Your host",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			eth1, err := xenorchestra.GetXoaPif(ctx, &xenorchestra.GetXoaPifArgs{
//				Device: "eth1",
//				Vlan:   -1,
//				HostId: pulumi.StringRef(host1.Id),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			eth2, err := xenorchestra.GetXoaPif(ctx, &xenorchestra.GetXoaPifArgs{
//				Device: "eth2",
//				Vlan:   -1,
//				HostId: pulumi.StringRef(host1.Id),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			// Create a bonded network from normal PIFs
//			_, err = xenorchestra.NewXoaBondedNetwork(ctx, "network", &xenorchestra.XoaBondedNetworkArgs{
//				NameLabel: pulumi.String("new network name"),
//				BondMode:  pulumi.String("active-backup"),
//				PoolId:    pulumi.String(host1.PoolId),
//				PifIds: pulumi.StringArray{
//					pulumi.String(eth1.Id),
//					pulumi.String(eth2.Id),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			// Create a bonded network from PIFs on VLANs
//			eth1Vlan, err := xenorchestra.GetXoaPif(ctx, &xenorchestra.GetXoaPifArgs{
//				Device: "eth1",
//				Vlan:   15,
//				HostId: pulumi.StringRef(host1.Id),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			eth2Vlan, err := xenorchestra.GetXoaPif(ctx, &xenorchestra.GetXoaPifArgs{
//				Device: "eth2",
//				Vlan:   15,
//				HostId: pulumi.StringRef(host1.Id),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			// Create a bonded network from normal PIFs
//			_, err = xenorchestra.NewXoaBondedNetwork(ctx, "network_vlan", &xenorchestra.XoaBondedNetworkArgs{
//				NameLabel: pulumi.String("new network name"),
//				BondMode:  pulumi.String("active-backup"),
//				PoolId:    pulumi.String(host1.PoolId),
//				PifIds: pulumi.StringArray{
//					pulumi.String(eth1Vlan.Id),
//					pulumi.String(eth2Vlan.Id),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// Deprecated: xenorchestra.index/bondednetwork.BondedNetwork has been deprecated in favor of xenorchestra.index/xoabondednetwork.XoaBondedNetwork
type BondedNetwork struct {
	pulumi.CustomResourceState

	Automatic pulumi.BoolPtrOutput `pulumi:"automatic"`
	// The bond mode that should be used for this network.
	BondMode pulumi.StringPtrOutput `pulumi:"bondMode"`
	// This argument controls whether the network should enforce VIF locking. This defaults to `false` which means that no filtering rules are applied.
	DefaultIsLocked pulumi.BoolPtrOutput `pulumi:"defaultIsLocked"`
	// The MTU of the network. Defaults to `1500` if unspecified.
	Mtu             pulumi.IntPtrOutput    `pulumi:"mtu"`
	NameDescription pulumi.StringPtrOutput `pulumi:"nameDescription"`
	// The name label of the network.
	NameLabel pulumi.StringOutput `pulumi:"nameLabel"`
	// The pifs (uuid) that should be used for this network.
	PifIds pulumi.StringArrayOutput `pulumi:"pifIds"`
	// The pool id that this network should belong to.
	PoolId pulumi.StringOutput `pulumi:"poolId"`
}

// NewBondedNetwork registers a new resource with the given unique name, arguments, and options.
func NewBondedNetwork(ctx *pulumi.Context,
	name string, args *BondedNetworkArgs, opts ...pulumi.ResourceOption) (*BondedNetwork, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.NameLabel == nil {
		return nil, errors.New("invalid value for required argument 'NameLabel'")
	}
	if args.PoolId == nil {
		return nil, errors.New("invalid value for required argument 'PoolId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource BondedNetwork
	err := ctx.RegisterResource("xenorchestra:index/bondedNetwork:BondedNetwork", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetBondedNetwork gets an existing BondedNetwork resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetBondedNetwork(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *BondedNetworkState, opts ...pulumi.ResourceOption) (*BondedNetwork, error) {
	var resource BondedNetwork
	err := ctx.ReadResource("xenorchestra:index/bondedNetwork:BondedNetwork", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering BondedNetwork resources.
type bondedNetworkState struct {
	Automatic *bool `pulumi:"automatic"`
	// The bond mode that should be used for this network.
	BondMode *string `pulumi:"bondMode"`
	// This argument controls whether the network should enforce VIF locking. This defaults to `false` which means that no filtering rules are applied.
	DefaultIsLocked *bool `pulumi:"defaultIsLocked"`
	// The MTU of the network. Defaults to `1500` if unspecified.
	Mtu             *int    `pulumi:"mtu"`
	NameDescription *string `pulumi:"nameDescription"`
	// The name label of the network.
	NameLabel *string `pulumi:"nameLabel"`
	// The pifs (uuid) that should be used for this network.
	PifIds []string `pulumi:"pifIds"`
	// The pool id that this network should belong to.
	PoolId *string `pulumi:"poolId"`
}

type BondedNetworkState struct {
	Automatic pulumi.BoolPtrInput
	// The bond mode that should be used for this network.
	BondMode pulumi.StringPtrInput
	// This argument controls whether the network should enforce VIF locking. This defaults to `false` which means that no filtering rules are applied.
	DefaultIsLocked pulumi.BoolPtrInput
	// The MTU of the network. Defaults to `1500` if unspecified.
	Mtu             pulumi.IntPtrInput
	NameDescription pulumi.StringPtrInput
	// The name label of the network.
	NameLabel pulumi.StringPtrInput
	// The pifs (uuid) that should be used for this network.
	PifIds pulumi.StringArrayInput
	// The pool id that this network should belong to.
	PoolId pulumi.StringPtrInput
}

func (BondedNetworkState) ElementType() reflect.Type {
	return reflect.TypeOf((*bondedNetworkState)(nil)).Elem()
}

type bondedNetworkArgs struct {
	Automatic *bool `pulumi:"automatic"`
	// The bond mode that should be used for this network.
	BondMode *string `pulumi:"bondMode"`
	// This argument controls whether the network should enforce VIF locking. This defaults to `false` which means that no filtering rules are applied.
	DefaultIsLocked *bool `pulumi:"defaultIsLocked"`
	// The MTU of the network. Defaults to `1500` if unspecified.
	Mtu             *int    `pulumi:"mtu"`
	NameDescription *string `pulumi:"nameDescription"`
	// The name label of the network.
	NameLabel string `pulumi:"nameLabel"`
	// The pifs (uuid) that should be used for this network.
	PifIds []string `pulumi:"pifIds"`
	// The pool id that this network should belong to.
	PoolId string `pulumi:"poolId"`
}

// The set of arguments for constructing a BondedNetwork resource.
type BondedNetworkArgs struct {
	Automatic pulumi.BoolPtrInput
	// The bond mode that should be used for this network.
	BondMode pulumi.StringPtrInput
	// This argument controls whether the network should enforce VIF locking. This defaults to `false` which means that no filtering rules are applied.
	DefaultIsLocked pulumi.BoolPtrInput
	// The MTU of the network. Defaults to `1500` if unspecified.
	Mtu             pulumi.IntPtrInput
	NameDescription pulumi.StringPtrInput
	// The name label of the network.
	NameLabel pulumi.StringInput
	// The pifs (uuid) that should be used for this network.
	PifIds pulumi.StringArrayInput
	// The pool id that this network should belong to.
	PoolId pulumi.StringInput
}

func (BondedNetworkArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*bondedNetworkArgs)(nil)).Elem()
}

type BondedNetworkInput interface {
	pulumi.Input

	ToBondedNetworkOutput() BondedNetworkOutput
	ToBondedNetworkOutputWithContext(ctx context.Context) BondedNetworkOutput
}

func (*BondedNetwork) ElementType() reflect.Type {
	return reflect.TypeOf((**BondedNetwork)(nil)).Elem()
}

func (i *BondedNetwork) ToBondedNetworkOutput() BondedNetworkOutput {
	return i.ToBondedNetworkOutputWithContext(context.Background())
}

func (i *BondedNetwork) ToBondedNetworkOutputWithContext(ctx context.Context) BondedNetworkOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BondedNetworkOutput)
}

// BondedNetworkArrayInput is an input type that accepts BondedNetworkArray and BondedNetworkArrayOutput values.
// You can construct a concrete instance of `BondedNetworkArrayInput` via:
//
//	BondedNetworkArray{ BondedNetworkArgs{...} }
type BondedNetworkArrayInput interface {
	pulumi.Input

	ToBondedNetworkArrayOutput() BondedNetworkArrayOutput
	ToBondedNetworkArrayOutputWithContext(context.Context) BondedNetworkArrayOutput
}

type BondedNetworkArray []BondedNetworkInput

func (BondedNetworkArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*BondedNetwork)(nil)).Elem()
}

func (i BondedNetworkArray) ToBondedNetworkArrayOutput() BondedNetworkArrayOutput {
	return i.ToBondedNetworkArrayOutputWithContext(context.Background())
}

func (i BondedNetworkArray) ToBondedNetworkArrayOutputWithContext(ctx context.Context) BondedNetworkArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BondedNetworkArrayOutput)
}

// BondedNetworkMapInput is an input type that accepts BondedNetworkMap and BondedNetworkMapOutput values.
// You can construct a concrete instance of `BondedNetworkMapInput` via:
//
//	BondedNetworkMap{ "key": BondedNetworkArgs{...} }
type BondedNetworkMapInput interface {
	pulumi.Input

	ToBondedNetworkMapOutput() BondedNetworkMapOutput
	ToBondedNetworkMapOutputWithContext(context.Context) BondedNetworkMapOutput
}

type BondedNetworkMap map[string]BondedNetworkInput

func (BondedNetworkMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*BondedNetwork)(nil)).Elem()
}

func (i BondedNetworkMap) ToBondedNetworkMapOutput() BondedNetworkMapOutput {
	return i.ToBondedNetworkMapOutputWithContext(context.Background())
}

func (i BondedNetworkMap) ToBondedNetworkMapOutputWithContext(ctx context.Context) BondedNetworkMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BondedNetworkMapOutput)
}

type BondedNetworkOutput struct{ *pulumi.OutputState }

func (BondedNetworkOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BondedNetwork)(nil)).Elem()
}

func (o BondedNetworkOutput) ToBondedNetworkOutput() BondedNetworkOutput {
	return o
}

func (o BondedNetworkOutput) ToBondedNetworkOutputWithContext(ctx context.Context) BondedNetworkOutput {
	return o
}

func (o BondedNetworkOutput) Automatic() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *BondedNetwork) pulumi.BoolPtrOutput { return v.Automatic }).(pulumi.BoolPtrOutput)
}

// The bond mode that should be used for this network.
func (o BondedNetworkOutput) BondMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BondedNetwork) pulumi.StringPtrOutput { return v.BondMode }).(pulumi.StringPtrOutput)
}

// This argument controls whether the network should enforce VIF locking. This defaults to `false` which means that no filtering rules are applied.
func (o BondedNetworkOutput) DefaultIsLocked() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *BondedNetwork) pulumi.BoolPtrOutput { return v.DefaultIsLocked }).(pulumi.BoolPtrOutput)
}

// The MTU of the network. Defaults to `1500` if unspecified.
func (o BondedNetworkOutput) Mtu() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *BondedNetwork) pulumi.IntPtrOutput { return v.Mtu }).(pulumi.IntPtrOutput)
}

func (o BondedNetworkOutput) NameDescription() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BondedNetwork) pulumi.StringPtrOutput { return v.NameDescription }).(pulumi.StringPtrOutput)
}

// The name label of the network.
func (o BondedNetworkOutput) NameLabel() pulumi.StringOutput {
	return o.ApplyT(func(v *BondedNetwork) pulumi.StringOutput { return v.NameLabel }).(pulumi.StringOutput)
}

// The pifs (uuid) that should be used for this network.
func (o BondedNetworkOutput) PifIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *BondedNetwork) pulumi.StringArrayOutput { return v.PifIds }).(pulumi.StringArrayOutput)
}

// The pool id that this network should belong to.
func (o BondedNetworkOutput) PoolId() pulumi.StringOutput {
	return o.ApplyT(func(v *BondedNetwork) pulumi.StringOutput { return v.PoolId }).(pulumi.StringOutput)
}

type BondedNetworkArrayOutput struct{ *pulumi.OutputState }

func (BondedNetworkArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*BondedNetwork)(nil)).Elem()
}

func (o BondedNetworkArrayOutput) ToBondedNetworkArrayOutput() BondedNetworkArrayOutput {
	return o
}

func (o BondedNetworkArrayOutput) ToBondedNetworkArrayOutputWithContext(ctx context.Context) BondedNetworkArrayOutput {
	return o
}

func (o BondedNetworkArrayOutput) Index(i pulumi.IntInput) BondedNetworkOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *BondedNetwork {
		return vs[0].([]*BondedNetwork)[vs[1].(int)]
	}).(BondedNetworkOutput)
}

type BondedNetworkMapOutput struct{ *pulumi.OutputState }

func (BondedNetworkMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*BondedNetwork)(nil)).Elem()
}

func (o BondedNetworkMapOutput) ToBondedNetworkMapOutput() BondedNetworkMapOutput {
	return o
}

func (o BondedNetworkMapOutput) ToBondedNetworkMapOutputWithContext(ctx context.Context) BondedNetworkMapOutput {
	return o
}

func (o BondedNetworkMapOutput) MapIndex(k pulumi.StringInput) BondedNetworkOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *BondedNetwork {
		return vs[0].(map[string]*BondedNetwork)[vs[1].(string)]
	}).(BondedNetworkOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*BondedNetworkInput)(nil)).Elem(), &BondedNetwork{})
	pulumi.RegisterInputType(reflect.TypeOf((*BondedNetworkArrayInput)(nil)).Elem(), BondedNetworkArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BondedNetworkMapInput)(nil)).Elem(), BondedNetworkMap{})
	pulumi.RegisterOutputType(BondedNetworkOutput{})
	pulumi.RegisterOutputType(BondedNetworkArrayOutput{})
	pulumi.RegisterOutputType(BondedNetworkMapOutput{})
}
